# コンピュータサイエンス基礎(基本情報技術者)<!-- omit in toc -->
コンピュータサイエンス基礎を学ぶことで、情報処理全般に関する基礎知識を習得できます。
この知識はコンピュータのハードウェア、ソフトウェア、通信等の処理や仕組みの理解につながります。

## 目次<!-- omit in toc -->
- [1. コンピュータ原理とハードウェア工学](#1-コンピュータ原理とハードウェア工学)
  - [1.1. ディジタル回路(内部演算・2進数等)](#11-ディジタル回路内部演算2進数等)
    - [1.1.1. n進数](#111-n進数)
    - [1.1.2. 基数変換](#112-基数変換)
    - [1.1.2. 2進数の計算と表現](#112-2進数の計算と表現)
      - [1.1.2.1. 2進数の和と差](#1121-2進数の和と差)
      - [1.1.2.2. シフト演算と積と商](#1122-シフト演算と積と商)
    - [1.1.3. コンピュータにおける小数点の扱い](#113-コンピュータにおける小数点の扱い)
      - [1.1.3.1. 固定小数点数](#1131-固定小数点数)
      - [1.1.3.2. 浮動小数点数](#1132-浮動小数点数)
      - [1.1.3.3. 浮動小数点数の正規化](#1133-浮動小数点数の正規化)
      - [1.1.3.4. 小数点誤差](#1134-小数点誤差)
      - [1.1.3.5. 桁あふれ誤差](#1135-桁あふれ誤差)
      - [1.1.3.6. 情報落ち](#1136-情報落ち)
      - [1.1.3.7. 打切り誤差](#1137-打切り誤差)
      - [1.1.3.8. けた落ち](#1138-けた落ち)
      - [1.1.3.9. 丸め誤差](#1139-丸め誤差)
    - [1.1.4. コンピュータ回路](#114-コンピュータ回路)
      - [1.1.4.1. 論理演算](#1141-論理演算)
      - [1.1.4.2. 基本論理回路を組み合わせた論理回路](#1142-基本論理回路を組み合わせた論理回路)
      - [1.1.4.3. 半加算器・全加算器](#1143-半加算器全加算器)
    - [1.1.3.4. ビットの操作と反転](#1134-ビットの操作と反転)
    - [1.1.3.5. デジタルデータの表記](#1135-デジタルデータの表記)
      - [1.1.3.5.1. ビット(Bit)とバイト(Byte)の関係と単位](#11351-ビットbitとバイトbyteの関係と単位)
      - [1.1.3.5.2. コンピュータにおける文字の表現方法](#11352-コンピュータにおける文字の表現方法)
      - [1.1.3.5.3. マルチメディアデータの表現](#11353-マルチメディアデータの表現)
  - [1.2. ハードウェア工学](#12-ハードウェア工学)
    - [1.2.1. アナログデータの制御](#121-アナログデータの制御)
      - [1.2.1.1. センサとアクチュエータ](#1211-センサとアクチュエータ)
      - [1.2.1.2. 制御方式](#1212-制御方式)
    - [1.2.2. CPU](#122-cpu)
      - [1.2.2.1. CPUとコンピュータ周辺5大機器](#1221-cpuとコンピュータ周辺5大機器)
      - [1.2.2.2. ノイマン型コンピュータ](#1222-ノイマン型コンピュータ)
      - [1.2.2.3. 主記憶装置のアドレス](#1223-主記憶装置のアドレス)
      - [1.2.2.4. CPUの命令実行手順とレジスタ](#1224-cpuの命令実行手順とレジスタ)
      - [1.2.2.5. 機械語のアドレス指定方式](#1225-機械語のアドレス指定方式)
      - [1.2.2.6. CPUの性能指標](#1226-cpuの性能指標)
      - [1.2.2.7. CPUの高速化技術](#1227-cpuの高速化技術)
    - [1.2.3. メモリ](#123-メモリ)
      - [1.2.3.1. メモリの分類](#1231-メモリの分類)
      - [1.2.3.2. RAMの種類](#1232-ramの種類)
      - [1.2.3.3. ROMの種類](#1233-romの種類)
      - [1.2.3.4. 主記憶装置・高速化手法](#1234-主記憶装置高速化手法)
      - [1.2.3.5. キャッシュメモリ](#1235-キャッシュメモリ)
      - [1.2.3.6. 主記憶装置への書き込み方式](#1236-主記憶装置への書き込み方式)
      - [1.2.3.7. ヒット率とアクセス時間](#1237-ヒット率とアクセス時間)
    - [1.2.4. ハードディスクとその他の補助記憶装置](#124-ハードディスクとその他の補助記憶装置)
      - [1.2.4.1. ハードディスクの構造と記憶方法](#1241-ハードディスクの構造と記憶方法)
      - [1.2.4.2. フラグメンテーション](#1242-フラグメンテーション)
      - [1.2.4.3. RAID](#1243-raid)
      - [1.2.4.4 ハードディスク以外の補助記憶装置](#1244-ハードディスク以外の補助記憶装置)
    - [1.2.5. その他のハードウェア](#125-その他のハードウェア)
      - [1.2.5.1. 入力装置](#1251-入力装置)
      - [1.2.5.2. ディスプレイ](#1252-ディスプレイ)
      - [1.2.5.3. プリンタ](#1253-プリンタ)
      - [1.2.5.4. 入出力インターフェス](#1254-入出力インターフェス)
      - [1.2.5.5. 無線インターフェス](#1255-無線インターフェス)
- [2. ソフトウェアとマルチメディア](#2-ソフトウェアとマルチメディア)
  - [2.1. 基本ソフトウェア](#21-基本ソフトウェア)
    - [2.1.1. OSのタスク](#211-osのタスク)
      - [ソフトウェアの分類](#ソフトウェアの分類)
      - [2.1.1.1. 基本ソフトウェアのプログラム](#2111-基本ソフトウェアのプログラム)
      - [2.1.1.2. 代表的なOS](#2112-代表的なos)
      - [2.1.1.3. OSの操作性(GUI/CUI)](#2113-osの操作性guicui)
      - [2.1.1.4. API(Application Program Interface)](#2114-apiapplication-program-interface)
      - [2.1.1.5. ソフトウェアによる自動化(RPA)](#2115-ソフトウェアによる自動化rpa)
    - [2.1.2. ジョブ管理](#212-ジョブ管理)
    - [2.1.3. タスク管理](#213-タスク管理)
    - [2.1.4. 実記憶管理](#214-実記憶管理)
    - [2.1.5. プログラムの再配置性と4つの性質](#215-プログラムの再配置性と4つの性質)
    - [2.1.6. 仮想記憶管理](#216-仮想記憶管理)
  - [2.2. ファイル管理](#22-ファイル管理)
    - [2.2.1. ファイルの正体](#221-ファイルの正体)
      - [2.2.1.1. データの種類と代表的なファイル形式](#2211-データの種類と代表的なファイル形式)
      - [2.2.1.2. マルチメディアデータの圧縮・伸張](#2212-マルチメディアデータの圧縮伸張)
    - [2.2.2. ディレクトリ](#222-ディレクトリ)
      - [2.2.2.1. ルートディレクトリとサブディレクトリ](#2221-ルートディレクトリとサブディレクトリ)
      - [2.2.2.2. カレントディレクトリ](#2222-カレントディレクトリ)
    - [2.2.3. ファイルの場所を示す手段](#223-ファイルの場所を示す手段)
      - [2.2.3.1. 絶対パスの表記](#2231-絶対パスの表記)
      - [2.2.3.2. 相対パスの表記](#2232-相対パスの表記)
    - [2.2.4. 汎用コンピュータにおけるファイルの扱われ方](#224-汎用コンピュータにおけるファイルの扱われ方)
      - [2.2.4.1. ファイルへのアクセス方法](#2241-ファイルへのアクセス方法)
      - [2.2.4.2. 順編成ファイル](#2242-順編成ファイル)
      - [2.2.4.5. 索引編成ファイル](#2245-索引編成ファイル)
      - [2.2.4.6. 区分編成ファイル](#2246-区分編成ファイル)
- [3. データベース](#3-データベース)
  - [3.1. DBMSと関係データベース](#31-dbmsと関係データベース)
    - [3.1.1. 関係型データベース](#311-関係型データベース)
    - [3.1.2. データの正規化](#312-データの正規化)
    - [3.1.3. 関係演算とビュー表](#313-関係演算とビュー表)
    - [3.1.4. スキーマ](#314-スキーマ)
  - [3.2. 主キーと外部キー](#32-主キーと外部キー)
  - [3.3. 正規化](#33-正規化)
    - [3.3.1. 非正規形の表](#331-非正規形の表)
      - [3.3.1.1. 第1正規形](#3311-第1正規形)
      - [3.3.1.2. 第2正規形](#3312-第2正規形)
      - [3.3.1.3. 第3正規形](#3313-第3正規形)
  - [3.3. SQLによるデータベース操作](#33-sqlによるデータベース操作)
  - [3.4. トランザクション管理と排他制御](#34-トランザクション管理と排他制御)
    - [3.4.1. トランザクション](#341-トランザクション)
    - [3.4.2. 排他制御](#342-排他制御)
    - [3.4.3. ACID特性](#343-acid特性)
    - [3.4.4. ストアドプロシージャ](#344-ストアドプロシージャ)
    - [3.4.5. データベースの障害管理](#345-データベースの障害管理)
    - [3.4.6. コミットとロールバック](#346-コミットとロールバック)
    - [3.4.7. 分散データベースと2相コミット](#347-分散データベースと2相コミット)
    - [3.4.8. ロールフォワード](#348-ロールフォワード)
- [4. ネットワーク](#4-ネットワーク)
  - [4.1. LANとWAN](#41-lanとwan)
    - [4.1.1. 通信路の方式とWANの技術](#411-通信路の方式とwanの技術)
    - [4.1.2. LANの接続方式(トポロジ)](#412-lanの接続方式トポロジ)
    - [4.1.3. イーサネット](#413-イーサネット)
    - [4.1.4. イーサネットのアクセス制御方式](#414-イーサネットのアクセス制御方式)
    - [4.1.5. トークンリングとトークンパッシング](#415-トークンリングとトークンパッシング)
    - [4.1.6. 無線LAN](#416-無線lan)
    - [4.1.7. クライアントとサーバの制御](#417-クライアントとサーバの制御)
  - [4.2. プロコトルとパケット](#42-プロコトルとパケット)
    - [4.2.1. プロコトルとOSI基本参照モデル](#421-プロコトルとosi基本参照モデル)
    - [4.2.3. ネットワークの伝送速度](#423-ネットワークの伝送速度)
  - [4.3. ネットワークの構成装置](#43-ネットワークの構成装置)
    - [4.3.1. LAN装置とOSI参照モデル](#431-lan装置とosi参照モデル)
    - [4.3.2. NIC(Network Interface Card)](#432-nicnetwork-interface-card)
    - [4.3.3. リピータ](#433-リピータ)
    - [4.3.4. ブリッジ](#434-ブリッジ)
    - [4.3.5. ハブ](#435-ハブ)
    - [4.3.6. ルータ](#436-ルータ)
    - [4.3.7. ゲートウェイ](#437-ゲートウェイ)
  - [4.4. データの誤り制御](#44-データの誤り制御)
  - [4.5. TCP/IPを用いたネットワーク](#45-tcpipを用いたネットワーク)
    - [4.5.1. TCP/IPの中核プロトコル](#451-tcpipの中核プロトコル)
    - [4.5.2. IPアドレスの種類](#452-ipアドレスの種類)
    - [4.5.3. IPアドレスの構成](#453-ipアドレスの構成)
    - [4.5.6. IPアドレスのクラス](#456-ipアドレスのクラス)
    - [4.5.7. ブロードキャスト](#457-ブロードキャスト)
    - [4.5.8. サブネットマスクによるネットワーク分割](#458-サブネットマスクによるネットワーク分割)
    - [4.5.9. MACアドレスとIPアドレスの違い](#459-macアドレスとipアドレスの違い)
    - [4.5.10. DHCPの仕組み](#4510-dhcpの仕組み)
    - [4.5.11. NATとIPマスカレード](#4511-natとipマスカレード)
  - [4.6. ドメイン名とDNS](#46-ドメイン名とdns)
  - [4.7. ネットワークのサービス](#47-ネットワークのサービス)
  - [4.8. サービスの識別(ポート番号)](#48-サービスの識別ポート番号)
  - [4.9. WWW(World Wide Web)](#49-wwwworld-wide-web)
    - [4.9.1. Webサーバへのリクエスト](#491-webサーバへのリクエスト)
    - [4.9.2 Webページの表示](#492-webページの表示)
    - [4.9.3. URLの正体](#493-urlの正体)
    - [4.9.4. CGI](#494-cgi)
  - [4.10. 電子メール](#410-電子メール)
    - [4.10.1. メールアドレス](#4101-メールアドレス)
    - [4.10.2. SMTP](#4102-smtp)
    - [4.10.3. POP](#4103-pop)
    - [4.10.4. IMAP](#4104-imap)
    - [4.10.5. MIME](#4105-mime)
    - [4.10.6. 電子メールの文字化け](#4106-電子メールの文字化け)
  - [4.11. ビッグデータと人工知能](#411-ビッグデータと人工知能)
- [5. セキュリティ](#5-セキュリティ)
  - [5.1.  ネットワークの脅威](#51--ネットワークの脅威)
    - [5.1.1. セキュリティマネジメントの3要素](#511-セキュリティマネジメントの3要素)
    - [5.1.4. ユーザ認証とアクセス管理](#514-ユーザ認証とアクセス管理)
    - [5.1.5. コンピュータウィルスの脅威](#515-コンピュータウィルスの脅威)
    - [5.1.6. ネットワークのセキュリティ対策](#516-ネットワークのセキュリティ対策)
      - [5.1.6.1. ファイヤーウォール](#5161-ファイヤーウォール)
      - [5.1.6.2. パケットフィルタリング](#5162-パケットフィルタリング)
      - [5.1.6.3. アプリケーションゲートウェイ](#5163-アプリケーションゲートウェイ)
      - [5.1.6.4. ペネトレーションテスト](#5164-ペネトレーションテスト)
    - [5.1.7. 暗号化技術とデジタル署名](#517-暗号化技術とデジタル署名)
- [6. システム/アプリの開発](#6-システムアプリの開発)
  - [6.1. システム開発フロー](#61-システム開発フロー)
    - [6.1.1. 開発の大まかなフロー](#611-開発の大まかなフロー)
    - [6.1.2. 要件定義](#612-要件定義)
    - [6.1.3. システム設計](#613-システム設計)
    - [6.1.4. テスト](#614-テスト)
      - [6.1.4.1. 単体テスト](#6141-単体テスト)
      - [6.1.4.2. 結合テスト](#6142-結合テスト)
      - [6.1.4.3. システムテスト](#6143-システムテスト)
      - [6.1.4.4. 運用テスト](#6144-運用テスト)
  - [6.2. システム開発手法](#62-システム開発手法)
  - [6.3. システム開発手法2](#63-システム開発手法2)
    - [6.3.1. RAD(Rapid Application Development)](#631-radrapid-application-development)
    - [6.3.2. アジャイル開発とXP(extreme Programming)](#632-アジャイル開発とxpextreme-programming)
    - [6.3.3. リバースエンジニアリング](#633-リバースエンジニアリング)
    - [6.3.4. マッシュアップ](#634-マッシュアップ)
  - [6.4. 業務のモデル化](#64-業務のモデル化)
    - [6.4.1. DED(Data Flow Diagram)](#641-deddata-flow-diagram)
    - [6.4.2. ER図(Entity-Relationship)](#642-er図entity-relationship)
  - [6.5. ユーザインターフェス(UI)](#65-ユーザインターフェスui)
    - [6.5.1. CUIとGUI](#651-cuiとgui)
    - [6.5.2. GUIで用いられる部品](#652-guiで用いられる部品)
  - [6.6. コード設計と入力チェック](#66-コード設計と入力チェック)
  - [6.7. モジュール分割](#67-モジュール分割)
  - [6.8. テスト](#68-テスト)
    - [6.8.1. テストの流れ](#681-テストの流れ)
      - [6.8.1.1. 単体テスト](#6811-単体テスト)
      - [6.8.1.2. 結合テスト](#6812-結合テスト)
      - [6.8.1.3. システムテスト](#6813-システムテスト)
    - [6.8.2. ブラックボックステストとホワイトボックステスト](#682-ブラックボックステストとホワイトボックステスト)
      - [6.8.2.1. ブラックボックステスト](#6821-ブラックボックステスト)
      - [6.8.2.2. ホワイトボックステスト](#6822-ホワイトボックステスト)
    - [6.8.3. テストデータの決めごと](#683-テストデータの決めごと)
    - [6.8.4. ホワイトボックステストの網羅基準](#684-ホワイトボックステストの網羅基準)
    - [6.8.5. トップダウンテストとボトムアップテスト](#685-トップダウンテストとボトムアップテスト)
    - [6.8.6. リグレッションテスト](#686-リグレッションテスト)
    - [6.8.7. バグ管理図と信頼度成長曲線](#687-バグ管理図と信頼度成長曲線)
    - [6.8.8. システム周りのマネジメント](#688-システム周りのマネジメント)
    - [6.9.9. スケジュール管理とアローダイアグラム](#699-スケジュール管理とアローダイアグラム)
    - [6.6.10. ITサービスマネジメント](#6610-itサービスマネジメント)
    - [6.6.11. サービスデスクの組織構造](#6611-サービスデスクの組織構造)
    - [6.6.12. システム監査](#6612-システム監査)
- [7.プログラムの作り方](#7プログラムの作り方)
  - [7.1. プログラミング言語](#71-プログラミング言語)
    - [7.1.1. 代表的な言語とその特徴](#711-代表的な言語とその特徴)
    - [7.1.2. インタプリタとコンパイラ](#712-インタプリタとコンパイラ)
  - [7.2. コンパイラ方式でのプログラムの実行手順](#72-コンパイラ方式でのプログラムの実行手順)
  - [7.3. 構造化プログラミング](#73-構造化プログラミング)
  - [7.4. 変数](#74-変数)
  - [7.5. アルゴリズムとフローチャート](#75-アルゴリズムとフローチャート)
  - [7.6. データの持ち方](#76-データの持ち方)
  - [7.7. ツリー構造](#77-ツリー構造)
  - [7.8. データ探索のアルゴリズム](#78-データ探索のアルゴリズム)
  - [7.9. データを整列させるアルゴリズム](#79-データを整列させるアルゴリズム)
  - [7.10. オーダ記法](#710-オーダ記法)
  - [7.11. オブジェクト指向プログラミング](#711-オブジェクト指向プログラミング)
  - [7.11. UML(Unified Modeling Language)](#711-umlunified-modeling-language)
- [8.システム構成と故障対策](#8システム構成と故障対策)
  - [8.1. コンピュータを動かす形態](#81-コンピュータを動かす形態)
  - [8.2. システムの性能指標](#82-システムの性能指標)
  - [8.3. システムを止めない手法](#83-システムを止めない手法)
  - [8.4. システムの信頼性と稼働率](#84-システムの信頼性と稼働率)
  - [8.5. バックアップ](#85-バックアップ)


# 1. コンピュータ原理とハードウェア工学
## 1.1. ディジタル回路(内部演算・2進数等)
### 1.1.1. n進数
　情報処理において用いられる進数としては、10進数、2進数、8進数、16進数などがあります。

| 10進数  | 2進数 |8進数|16進数|
| ---- | ---- | ---- | ---- |
|  0  |  0  | 0 | 0 |
|  1  |  1  | 1 | 1 |
|  2  |  10  | 2 | 2 |
|  3  |  11  | 3 | 3 |
|  4  |  100  | 4 | 4 |
|  5  |  101  | 5 | 5 |
|  6  |  110  | 6 | 6 |
|  7  |  111  | 7 | 7 |
|  8  | 1000 | 10 | 8 |
|  9  | 1001 | 11 | 9 |
| 10 | 1010 | 12 | 10 |

### 1.1.2. 基数変換
　基数変換はn進数の数をm進数の数の表記に変換することです。

#### n進数から10進数への変換<!-- omit in toc -->
1101.011(2)の10進数への変換
| 2進数  | 1 | 1 | 0 | 1 | . | 0 | 1 | 1 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 重み | 2^3 | 2^2 | 2^1 | 1 | + | 1/(2^1) | 1/(2^2) | 1/(2^3) |
| 計算値 | 8 | 4 | 2 | 1 | + | 1/2 | 1/4 | 1/8 |

計算： 8x1+4x1+2x0+1x1+1/2x0+1/4x1+1/8x1 = 13.375

160.4(8)の10進数への変換
| 2進数  | 1 | 6 | 0 | . | 4 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 重み | 8^2 | 8^1 | 1 | + | 1/8 |
| 計算値 | 64 | 8 | 1 | + | 1/8 |

計算:　64x1+8x6+1x0+(1/8)x4=64+48+0+1/2=112.5

#### 10進数からn進数への変換<!-- omit in toc -->
整数部分は素因数分解(割り算)、小数部分は因数結合(掛け算)で変換する。

ex)13.32の2進数への変換
13/2 = 6...1 => 6/2 = 3...0 => 3/2 = 1...1 => 1/2 = 0....1 
=> 1011
0.32 x 2 = 0.64 => 0.64 x 2 => 1.28 => 1.28 x 2 => 2.56
=> 0.010

∴ 1011.010....

### 1.1.2. 2進数の計算と表現
#### 1.1.2.1. 2進数の和と差

和に関しては10進数の足し算と同じように考え、
差に関しては正の数をビット反転して最下位桁に1を足したもの(2の補数)で和をとる

ex)101(2)-11(2) = 0101 + (1100+1) = 0101 + 1101 = 10010 => 10

#### 1.1.2.2. シフト演算と積と商
2進数を表すビット列を左右にずらす作業を**シフト演算**と呼びます。

##### 左論理シフトと右論理シフト<!-- omit in toc -->
左論理シフトは2^n倍を表し、右論理シフトは1/2^nを示す。
また左論理シフトにより値域を超えた場合は**オーバーフロー**と呼ぶ。
右論理シフトにより値域を超えた場合は余りである。

##### 算術シフト<!-- omit in toc -->
符号を考慮して行うシフト演算のことである。
積に関しては左論理シフトをして空になった桁は0で埋めて、ビット値域の最上位桁に+αで符号ビットを合わせる。
商に関しては右論理シフトをしてビット値域の不足分とビット値域の最上位桁に+αで符号ビットで埋める。
二つともはみ出した桁数は削除する。

**積**

2^nを利用した和を利用して計算。

ex) n x 7 = n x (2^2 + 2 + 1) = n x 2^2 + n x 2 + n x 1

**商**

2^nを利用した差を利用して計算。

ex) 15/3 => 1111(2)/11(2) => 1111(2) - 1100(2) => 2^2 + 2^0 =5 =>101(2)

### 1.1.3. コンピュータにおける小数点の扱い
#### 1.1.3.1. 固定小数点数
ビット列のどの位置に小数点があるかを暗黙的に決めて扱う小数表現

#### 1.1.3.2. 浮動小数点数
指数表記を用いて小数点以下を表現する手法
コンピュータはメモリに符号と指数部と仮数部に値を分け値を保持します。
符号には+-の情報を、指数部には累乗の情報を、仮数部には値本体を保存します。
   
#### 1.1.3.3. 浮動小数点数の正規化
正規化を行うことで有効な桁数を多くとることができます。
そうすることで誤差分が減り、値の精度を高めることが可能です。

#### 1.1.3.4. 小数点誤差
表記上、割り算をした場合割り切れずに永遠に続く数字ができることがある。
それは無限小数と呼ばれる。

#### 1.1.3.5. 桁あふれ誤差
浮動小数点数の指数部が範囲を超過して精度が保てずに生じる誤差である。
限りなく大きい数字や限りなく小さい実数で起こる。

#### 1.1.3.6. 情報落ち
絶対値の大きい数と小さい数の加減算を行ったときに、絶対値の小さい値が計算結果に反映されないことで生じる誤差である。

#### 1.1.3.7. 打切り誤差
計算処理を終わるまで待たずに途中で打ち切ることで生じる誤差である。

#### 1.1.3.8. けた落ち
絶対値がほぼ等しい数字の差を求めた際に、有効桁数が大きく減ることで生じる誤差である。

#### 1.1.3.9. 丸め誤差
表現可能な桁数(値域)を超えてしまったため、最小桁より小さい数字が四捨五入や切り上げ、切り捨てなどを行 　　
うことで生じる誤差である。

### 1.1.4. コンピュータ回路
#### 1.1.4.1. 論理演算
コンピュータにおいて、**AND,OR,NOT**等の論理演算をビットの演算に用いることで様々処理を実現している。

<img src="https://image.jimcdn.com/app/cms/image/transf/dimension=origxorig:format=png/path/s9a246d2d2c830e8d/image/i77bdab51b44d4889/version/1424716737/image.png" width="0%">

##### AND回路<!-- omit in toc -->
AND回路の真理値表は以下の通りです。

Y = A・B
| A  | B | Y |
| ---- | ---- | ---- |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

##### OR回路<!-- omit in toc -->
OR回路の真理値表は以下の通りです。

Y = A+B
| A  | B | Y |
| ---- | ---- | ---- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

##### NOT回路<!-- omit in toc -->
AND回路の真理値表は以下の通りです。

Y = /A
| A  | Y |
| ---- | ---- |
| 0 | 1 |
| 1 | 0 |

#### 1.1.4.2. 基本論理回路を組み合わせた論理回路
AND,OR,NOTを組み合わせると様々な論理回路を作成できます。
その代表例として**NAND,NOR,XOR**があります。
##### NAND回路<!-- omit in toc -->
NAND回路はAND回路とNOT回路を直列に組み合わせた回路です。
NAND回路の真理値表は以下の通りです。

Y = /(A・B)
| A  | B | Y |
| ---- | ---- | ---- |
| 0 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

##### NOR回路<!-- omit in toc -->
NOR回路はOR回路とNOT回路を直列に組み合わせた回路です。
NOR回路の真理値表は以下の通りです。

Y = /(A+B)
| A  | B | Y |
| ---- | ---- | ---- |
| 0 | 0 | 1 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 0 |

##### XOR回路<!-- omit in toc -->
XOR回路はNOT回路とAND回路を接続したもののNOTがない側を並列誘引し、AND出力側をOR回路で組み合わせた回路です。
XOR回路の真理値表は以下の通りです。

Y = A⊕B
| A  | B | Y |
| ---- | ---- | ---- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

#### 1.1.4.3. 半加算器・全加算器
加算器には下位の桁上がりを考慮しない半加算器とそれを考慮する全加算器があります。

##### 半加算器<!-- omit in toc -->
半加算器はAND回路とXOR回路を並列誘引接続し組み合わせた回路で作られます。

![Image 1](http://arduinopid.web.fc2.com/new601.png)

入力値A,B、出力値C,Sとすると半加算器の真理値表は以下の通りです。
| A  | B | C |
| ---- | ---- | ---- |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

| A  | B | S |
| ---- | ---- | ---- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

##### 全加算器<!-- omit in toc -->
全加算器は半加算器とOR回路を並列接続で組み合わせた回路です。
OR回路側の出力を上位桁、2つ目以降の半加算器の出力を下位桁として扱えます。

![Image 1](http://arduinopid.web.fc2.com/new602.png)

### 1.1.3.4. ビットの操作と反転
#### ビットの反転<!-- omit in toc -->
ビットの反転にはXOR回路を用います。
反転方法は以下の通りです。

1. 反転したいビット列を用意
2. 反転させたい位置のみを1それ以外を0にしたビット列を用意
3. 上記2つのビット列でXORをとる

#### ビットの取り出し<!-- omit in toc -->
ビットの取り出しにはAND回路を用います。
取り出し方法は以下の通りです。

1. ビットを取り出したいビット列を用意
2. ビットを取り出したい位置に1それ以外を0にしたビット列を用意
3. 上記2つのビット列でANDをとる

***
### 1.1.3.5. デジタルデータの表記
#### 1.1.3.5.1. ビット(Bit)とバイト(Byte)の関係と単位
8bitをひとまとまりにした単位をByteとしています。
記憶容量等はByteを用いて表記されます。

<img src="http://zokeifile.musabi.ac.jp/wpwp/wp-content/uploads/2014/08/188_byte_01_jp.jpg" width="50%">

またByteの各単位系は以下の通りです。

記憶容量などの大きい数値を表す単位系

| bit  | 乗数 | 単位 |
| ---- | ---- | ---- |
| キロ(K) | 3 | 1KB=1024B |
| メガ(M) | 6 | 1MB=1024KB |
| ギガ(G) | 8 | 1GB=1024MB |
| テラ(T) | 12 | 1TB=1024GB |

情報速度など小さい数値を表す単位系

| bit  | 乗数 | 単位 |
| ---- | ---- | ---- |
| ミリ(m) | -3 | - |
| マイクロ(μ) | -6 | - |
| ナノ(n) | -8 | - |
| ピコ(p) | -12 | - |

#### 1.1.3.5.2. コンピュータにおける文字の表現方法
コンピュータは数値を文字に割り当てることで文字を表現しています。

ASCIIの文字コード表の例です。このコードでは1文字当たり7bitです。
<img src="https://www.pahoo.org/e-soul/webtech/encode/encode02-01-01.png" width="50%">

文字コードの種類には以下のような種類があります。
* ASCII ・・・ 米国規格会が定めた基本的な文字コード、アルファベットと数字といくつかに記号のみを表し1文字7bitです
* EBCDIC ・・・ IBMが定めた文字コードで1文字8bitで表し、大型コンピュータで用いられる
* Shift-JIS ・・・ ASCIIの文字と混在させて使える日本語文字コード表。ひらがなや漢字、カタカナが使えます。windowsで使われており、1文字2Byteです
* EUC ・・・ 拡張UNIXと呼ばれ、UNIX系のOSで使われる日本語文字コード表、1文字基本2Byte、補助漢字は3Byteで表される
* Unicode ・・・ 全世界の文字コードを1つにしようとして作成された文字コード、現在は1文字4Byteで、ISOにより標準化された

#### 1.1.3.5.3. マルチメディアデータの表現
写真や音声、動画などのマルチメディアデータは連続したデータであるため、ディジタルデータへの変換する作業が必要です。
##### 画像データ<!-- omit in toc -->
画像データは点の情を法を集めたものであり、ドットと呼ばれる単位で構成される。

**1ドット当たりの情報量**
| 色数  | 画像 |
| ---- | ---- |
| 2色 | 白黒画像、1ドットにつき1bit |
| 16色 | 1ドットにつき4bit |
| 256色 | 1ドットにつき8bit |
| 65535色 | 1ドットにつき16bit |
| 2^24(25ビット) | フルカラー画像、1ドット24bit |

##### 音声データ<!-- omit in toc -->
音声データはアナログ波形のデータであり、ディジタル化して数値表現する方式は**PCM**である。

**標本化**

アナログデータを一定の単位時間で区切り、時間ごとの信号を標本として抽出する処理
サンプリング周波数はどの間隔で標本を得るか示すものである。

例：CDのサンプリング周波数が44100Hz,量子化ビット数が16ビットだとするとサンプリング周期は？
Ts = 1/44100

**量子化**

サンプリングしたデータを段階数に当てはめ整数値に置き換える処理
このときの量子化した段階の数を量子化ビット数と呼ぶ

**符号化**

量子化で得たデータを2進数に直す処理

## 1.2. ハードウェア工学
### 1.2.1. アナログデータの制御
#### 1.2.1.1. センサとアクチュエータ
コンピュータはセンサやアクチュエータを用いて、アナログ情報の取得や機械的動作を実現しています。

* センサ ・・・ 熱、光などの自然界の情報を電気信号に変換し、A/D変換しコンピュータに伝えます
* アクチュエータ ・・・ 電気信号を物理的な動作量に変換する装置です。モータやアームなどが例です

#### 1.2.1.2. 制御方式
* シーケンス制御 ・・・ 定められた順序や条件に従い、逐次処理を進めていく制御方式
* フィードバック制御 ・・・ 現在の状況を定期的に計測し、目標値とのずれを入力に戻し、出力結果を目標値と一致させようとする制御方式


### 1.2.2. CPU
#### 1.2.2.1. CPUとコンピュータ周辺5大機器

<img src="https://www.kenschool.jp/blog/wp-content/uploads/2019/11/6884a465454f7ac58c2aee739c90f61c.png" width="50%">
<img src="https://www.kenschool.jp/blog/wp-content/uploads/2019/11/b07a996215cdc9d6134cb764ce76681d.png" width="50%">

#### 1.2.2.2. ノイマン型コンピュータ
ノイマン型コンピュータは以下の特徴を持つコンピュータであり、現在のほとんどのコンピュータがノイマン型である。

* プログラム内蔵方式 ・・・ プログラム実行時にプログラムを予め主記憶装置上に読み込んでおく方式
* 逐次制御方式 ・・・ 命令を1つずつ取り出し順番に実行していく方式

#### 1.2.2.3. 主記憶装置のアドレス
主記憶装置にはプログラムの他に処理中の演算結果などを含む様々なデータが記憶されている。
主記憶装置は一定の区画ごとに番号が振られており、それを指定することで任意の場所の読み書きが可能である。
この番号は**アドレス**と呼ばれる。

#### 1.2.2.4. CPUの命令実行手順とレジスタ
CPUが命令を実行するために取り出された情報は**レジスタ**と呼ばれるCPU内部の記憶装置に保存される。

CPUの命令実行手順は以下の通りです。
1. 命令の取り出し(フェッチ)
2. 命令の解読
3. オペランド呼び出し
4. 命令実行
CPUはこれらの動作を繰り返します。

##### レジスタの種類<!-- omit in toc -->
レジスタの種類には以下に様なものがある。

<img src="http://category10.web.fc2.com/image/table_cat1_7_1.png" width="60%">

##### 命令取り出し(フェッチ)<!-- omit in toc -->
プログラムカウンタが取り出す命令のメモリアドレスを持つ。
プログラムカウンタに従ってアドレスを参照し命令を取り出し、命令レジスタにそれを記憶させる。
それが終わった後プログラムカウンタの値をインクリメントする。

##### 命令解読<!-- omit in toc -->
命令レジスタに登録された命令は**命令部**と**オペランド部**で構成される。
命令部は命令の種類を示すコードが、オペランド部には処理対象となるデータを収めたメモリアドレスが格納される。
命令部の中身は命令デコーダへ送られます。
また、命令デコーダは命令部のコードを解読し、制御信号を必要な装置に通知します。

##### オペランド読み出し<!-- omit in toc -->
オペランド(処理対象データ)は読み出しデータのメモリアドレスなどが格納され、
これを参照することでデータを読み出し、汎用レジスタに記憶させる。

##### 命令実行<!-- omit in toc -->
汎用レジスタからALUに処理データを読み出し演算し、その結果を汎用レジスタに書き戻す。

#### 1.2.2.5. 機械語のアドレス指定方式
コンピュータは**機械語**と呼ばれる0と1で構成された命令語を理解し処理します。
命令レジスタに登録された命令のオペランド部には必ずメモリアドレスが入っているとは限らず、
基準値からの差分や、メモリアドレスが入っているメモリアドレスなど複雑なものが入っていることもあります。
このように何かしらの計算によりアドレスを求める方式は**アドレス修飾(アドレス指定)** と呼ばれます。

##### 即値アドレス指定方式<!-- omit in toc -->
対象データそのものがオペランド部に入っている方式。

##### 直接アドレス指定方式<!-- omit in toc -->
オペランド部に記載してあるアドレスがそのままのアドレスとして使える方式。

##### 間接アドレス指定方式<!-- omit in toc -->
オペランド部に記載されているアドレス中に「対象となるデータが入ってる場所を示すメモリアドレス]が記載されている。

##### インデックスアドレス指定方式<!-- omit in toc -->
オペランド部の値にインデックス(指標)レジスタの値を加算することで実効アドレスを求める。

##### ベースアドレス指定方式<!-- omit in toc -->
オペランド部の値にベースレジスタの値を加算することで実効アドレスを求める。

##### 相対アドレス指定方式<!-- omit in toc -->
オペランド部の値にプログラムカウンタの値を加算することで実効アドレスを求める。

#### 1.2.2.6. CPUの性能指標
CPUの性能は**クロック周波数、CPI、MIPS**等の指標値を用い評価される。

##### クロック周波数<!-- omit in toc -->
CPUはクロック周波数に合わせて動作を行い、クロック周波数が大きいほど高性能であると言える。
1周期で命令を1実行できるため、クロック周波数が1GHz、CPIが1クロックである場合10^9の命令を1秒で実行できることを表す。
またクロック周波数を1で割ったものは**クロックサイクル時間**と呼ばれ、クロック当たりの所要時間を示す。

##### CPI<!-- omit in toc -->
CPI(Clock Per Instruction)は1命令当たり何クロック必要かを表すものである。

##### MIPS<!-- omit in toc -->
MIPS(Million Instruction Per Second)は1秒間に実行できる命令の数を表したものである。

#### 1.2.2.7. CPUの高速化技術
##### パイプライン処理<!-- omit in toc -->
パイプライン処理は複数の命令を並列して実行する処理であり、全体の処理効率が高い処理です。
この処理では次々と命令を先読みしていってるため分岐命令が出た際に先読み分が無駄になることがある。
それは**分岐ハザード**と呼ばれる。

##### 分岐予測と投機実行<!-- omit in toc -->
パイプライン処理では分岐処理(ex:if)が発生します。この結果が明確になるまで次の命令を処理できないという問題があります。
そのため**分岐予測**と呼ばれる、次の命令はどれかを予想して無駄な待ち時間を発生させないようにする処理があります。
この処理に基づいて分岐先の命令を実行する手法が**投機実行**である。

##### スーパーパイプラインとスーパースカラ<!-- omit in toc -->
パイプライン処理による高速化をさらに進める手法として**スーパーパイプラインやスーパースカラ**がある。

###### スーパーパイプライン<!-- omit in toc -->
処理のレーンのステージをさらに細かいステージに分割することでパイプライン処理の効率アップを図るものである。

###### スーパースカラ<!-- omit in toc -->
パイプライン処理を行う回路を複数持たせることで全く同時に複数の命令を実行できるようにしたものである。

##### CISCとRISC<!-- omit in toc -->
CPUのアーキテクチャには高機能な命令を持つ**CISC**と単純な命令のみで構成される**RISC**がある。

**CISC**

CISCはCPUに高機能な命令を持たせることで、一つの命令で複数な処理を実現するアーキテクチャである。
**マイクロプログラム**をCPU内部に記憶させることで高機能な命令が実現可能。

**RISC**

RISCはCPU内部に単純な命令しか持たない代わりに、それらをハードウェアの実で実装し、一つ一つの命令を高速に処理するアーキテクチャである。
**ワイヤドロジック**によりすべての命令をハードウェア的に実装される。

<img src="https://image.itmedia.co.jp/edn/articles/1404/07/tt140407ST01_02.jpg" width="60%">


### 1.2.3. メモリ
#### 1.2.3.1. メモリの分類
メモリはコンピュータの動作に必要なデータを記憶する装置である。
半導体メモリには2種類あり、それぞれ**RAMとROM**と呼ばれる。

<img src="https://image.itmedia.co.jp/edn/articles/1704/24/l_tt170426_QA37_001.jpg" width="60%">

#### 1.2.3.2. RAMの種類
**DRAM**
安価で容量が大きい、主記憶装置に用いられるメモリである。読み書き速度はSRAMよりも低速であり、記憶内容の維持のためには定期的に再書き込みするリフレッシュ動作が必要である
**SRAM**
DRAMよりも非常に高速であるが高価である。小規模のキャッシュメモリとして用いられ、記憶内容の維持にリフレッシュ動作は不要である。

| 種類  | リフレッシュ動作 | 速度 | 集積度 | 価格 | 用途 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| DRAM | 必要 | 低速 | 高 | 安価 | 主記憶装置 |
| SRAM | 不要 | 高速 | 低 | 高価 | キャッシュメモリ |

#### 1.2.3.3. ROMの種類
* マスクROM ・・・ 読み出し専用のメモリであり、製造時にデータが書き込まれている。
* PROM ・・・ ユーザの手でプログラミングし書き換えれるROMである
   * EPROM ・・・ 紫外線でデータを消去し書き換えられる
   * EEPROM ・・・ 電気的にデータを消去し書き換えられる
   * フラッシュメモリ ・・・ ブロック単位でデータを消去し書き換えられる

#### 1.2.3.4. 主記憶装置・高速化手法
記憶装置ごとのアクセス速度は以下の通りです。

CPUのレジスタ > メモリ(主記憶装置) > ハードディスクの磁気ディスク装置

これらの速度キャップを吸収できれば全体の効率がよくなり高速化できる。
そこで各記憶装置の待ち時間によるロスを減らすために**キャッシュ**がある。
レジスタとメモリの間に設ける**キャッシュメモリ**や、メモリとハードディスクの間に設ける**ディスクキャッシュ**がある。

#### 1.2.3.5. キャッシュメモリ
<img src="https://basics.k-labo.work/wordpress/wp-content/uploads/2017/10/92e2232428c66bbe53b89ea2a0092339-1.png" width="60%">

#### 1.2.3.6. 主記憶装置への書き込み方式
キャッシュメモリは書き込みでも使われ、あるタイミングで主記憶装置にも反映されます。
主記憶装置を書き換える方式に、**ライトスルー方式、ライトバック方式**の2つがある。

##### ライトスルー方式<!-- omit in toc -->
この方式はキャッシュメモリへの書き込みと同時に主記憶装置にも書き込みます。
##### ライトバック方式<!-- omit in toc -->
この方式は通常はキャッシュメモリにのみ書き込みを行い、キャッシュメモリから追い出されるデータが発生するとそれを主記憶装置に書き込み更新します。

#### 1.2.3.7. ヒット率とアクセス時間
キャッシュメモリに目的とするデータが入っている確率は**ヒット率**で表します。
また、キャッシュメモリを使ったコンピュータの平均アクセス時間(実効アクセス時間)はヒット率で求まります。

キャッシュメモリへのアクセス時間：キャッシュメモリのアクセス時間xヒット率
主記憶装置へのアクセス時間：主記憶装置のアクセス時間x(1-ヒット率)
上記2式の和 => 実効アクセス時間

#### 1.2.3.8. メモリインタリーブ<!-- omit in toc -->
主記憶装置へのアクセスを高速化する技術に**メモリインタリーブ**がある。
この手法では主記憶装置中を複数の区画に分け、複数の区画に同時アクセスすることで連続した番地のデータを一気に読み出します。

---
### 1.2.4. ハードディスクとその他の補助記憶装置
#### 1.2.4.1. ハードディスクの構造と記憶方法
ハードディスクは高速回転するディスクに磁気ヘッドを使って情報を読み書きする。

##### セクタとトラック<!-- omit in toc -->
<img src="http://park12.wakwak.com/~eslab/pcmemo/hdisk/images/logical.gif" width="50%">

##### ハードディスクの記憶領域<!-- omit in toc -->
以下の使用のハードディスクの場合の総容量を求めてみます。
| パラメータ  | 値 |
| ---- | ---- |
| シリンダ数 | 1500 |
| 1シリンダあたりのトラック数 | 20 |
| 1トラックあたりのセクタ数 | 40 |
| 1セクタあたりのバイト数 | 512 |

{(512x4)x20}x1500 = 6.144x10^8 Byte

##### ファイルの記録<!-- omit in toc -->
ハードディスクの最小単位はセクタである。
OSがファイルの読み書きをする場合は、複数のセクタを1ブロックとみなした**クラスタ**という単位で行われる。

##### データへのアクセス時間<!-- omit in toc -->
ハードディスクへのデータの読み書きには以下3ステップで行われます。
* シーク(位置決め)
* サーチ(回転待ち)
* データ転送
シークからサーチまでかかる時間は待ち時間として扱われます。
つまりアクセス時間はシークとサーチの時間とデータ転送時間の和で表せます。

以下のパラメータを用いてアクセス時間を算出してみます。
| パラメータ  | 値 |
| ---- | ---- |
| 回転速度 | 5000t/m |
| 平均シーク時間 | 20ms |
| 1トラックあたりの記憶容量 | 15000Byte |

平均サーチ時間は{60x1000)ms/5000=12ms, 12ms/2=6ms
データ転送時間は15000Byte/12ms = 1250Byte/ms, 5000/1250=4ms
より 20ms + 6ms + 4ms = 30ms

#### 1.2.4.2. フラグメンテーション
ハードディスク上でデータの書き込みと消去を繰り返すと、プラッタの空き容量は分散化されます。
また、その状態で新しく書き込みを行うと、書き込み箇所が離散化されます。
このようにファイルがあちこちの領域に分けられ断片化する状態**フラグメンテーション(断片化)** と呼ばれます。

##### デフラグによる再整理<!-- omit in toc -->
フラグメンテーションにより1つのファイルを読み書きするのに時間がかかります。
これを解決するために行われる作業に**デフラグメンテーション(デフラグ)** というものがあります。
これは断片化したファイルデータを連続した領域に並べ直してフラグメンテーションを解決するものです。

#### 1.2.4.3. RAID
複数のハードディスクを組み合わせ用いて、仮想的なハードディスクを構築運用する技術が**RAID**です。
これらの用途はハードディスクの高速化や信頼性向上に用いられる。
RAIDはRAID0からRAID6までの7種類あり、求める速度や信頼性に応じて各種類を組み合わせて使用できます。

##### RAIDの代表的な種類<!-- omit in toc -->
###### RAID0(ストライピング)<!-- omit in toc -->
RAID0は一つのデータを2台以上のディスク分散させて書き込みます。

###### RAID1(ミラーリング)<!-- omit in toc -->
RAID1は2台以上のディスクに対して常に同じデータを書き込みます。

###### RAID5<!-- omit in toc -->
RAID5は3台以上のディスクを使って、データと同時にパリティと呼ばれる誤り訂正符号も分散させて書き込みます。

#### 1.2.4.4 ハードディスク以外の補助記憶装置
駆動装置から記憶装置を簡単に取り出せるものは**リムーバブルメディア**と呼ばれます。

##### 光ディスク(CD・DVD)<!-- omit in toc -->
レーザ光線によりデータの読み書きを行うのが光ディスク装置です。

* CD ・・・ 記憶容量は650MBと700MBの2種類あり安価で大容量である。種類には再生専用と追記型、書き換え可能型の3種類である
   * CD-ROM ・・・ 読み込み専用である再生用CD
   * CD-R ・・・ 一度だけ書き込める追記型のCD
   * CD-RW ・・・ 何度でも書き換え可能なCD
* DVD ・・・ CDよりも波長の短い赤色レーザで記録し、ビットの高密度化が可能であるため大容量を実現している
   * DVD-ROM ・・・ 再生専用のDVD
   * DVD-R ・・・ 追記型のDVD
   * DVD-RW ・・・ 書き換え可能なDVD

##### 光磁気ディスク(MO)<!-- omit in toc -->
レーザ光線と磁気によりデータの読み書きを行うのが**光磁気ディスク装置**である。

##### 磁気テープ(ビデオテープetc)<!-- omit in toc -->
磁性体が塗布されたテープ状のフィルムに磁気を使って読み書きを行うカセット型の記憶媒体が**磁気テープ装置**である。
ブロックごとにスタート、ストップすることをせずに連続的に読み書きを行うものは**ストリーマ**と呼ばれる。

##### フラッシュメモリ<!-- omit in toc -->
EEPROMの一種を補助記憶媒体に転用したものが**フラッシュメモリ**である。
これを利用したものにメモリカードやUSBメモリがある。

##### SSD(Solid State Drive)<!-- omit in toc -->
SSDは近年HDDの代替として注目を集めています。
SSDはフラッシュメモリを記憶媒体として内蔵する装置である。
機会的な駆動部分がなく、省電力で衝撃にも強い。また高速に読み書きが可能。
ただしSSDには書き込み回数に上限があります。

---
### 1.2.5. その他のハードウェア
#### 1.2.5.1. 入力装置
##### キーボードとポインティングデバイス<!-- omit in toc -->
| 装置  | 説明 |
| ---- | ---- |
| キーボード | 数字や文字を入力するための装置 |
| マウス | マウスの移動情報を入力し画面上の位置を示す装置 |
| トラックパッド | 画面を触れることで移動情報を指し示す装置 |
| タッチパネル | 画面を触れることで画面の位置を指し示す装置 |
| タブレット | パネル上でペン等を動かすことで位置情報を入力する装置 |
| ジョイスティック | スティックを傾けることで位置情報を入力する装置 |

##### 読み取り装置とバーコード<!-- omit in toc -->
| 装置  | 説明 |
| ---- | ---- |
| イメージスキャナ | 絵や画像をデータとして読み取る装置 |
| OCR | 印字された文字や手書き文字などを読み取る装置 |
| OMR | マークシートの読み取り位置を認識する装置 |
| キャプチャカード | ビデオデッキなどの映像装置から、映像をデジタルデータとして取り込む装置 |
| デジタルカメラ | フィルムの代わりにCCDを用いて画像をデジタルデータとして記憶する装置 |
| バーコードリーダ | バーコードを読み取る装置 |

バーコードには2種類あり、商品用には**JANコード**、2次元コードには**QRコード**がある。

#### 1.2.5.2. ディスプレイ
ディスプレイはコンピュータ出力を画面に表示します。
例としてブラウン管型のCRTディスプレイや液晶で薄型の液晶ディスプレイなどがあります。
またディスプレイが表示されるきめ細かさは**解像度**と呼ばれます。
1ドット当たりRGBの光を重ねて表現されます。

##### VRAM(ビデオRAM)<!-- omit in toc -->
コンピュータは画面に表示される内容はVRAMと呼ばれる専用のメモリに保持する。
VRAMの容量によって扱える解像度と色数が異なります。
例えば、1024x768ドットの表示能力を持つディスプレイがある場合、16bit(65536色)を表示させたい場合のVRAMの容量は以下の通りです。

1024x768x16=12582912bit, 1byte=8bitなため、12582912bit/8 ≒1.6MByte

##### ディスプレイの種類<!-- omit in toc -->
| 装置  | 説明 |
| ---- | ---- |
| CRTディスプレイ | ブラウン管を用いたディスプレイ、奥行きが必要であり消費電力も大きい |
| 液晶ディスプレイ | 電圧により液晶を制御しているディスプレイ、薄型で消費電力も小さい |
| 有機ELディスプレイ | 有機化合物に電圧を加えることで発光する仕組みを用いたディスプレイ、バックライトが不要である |
| プラズマディスプレイ | プラズマ放電による発行を用いたディスプレイ、高電圧が必要である |

#### 1.2.5.3. プリンタ
コンピュータの処理結果を印刷する装置
##### プリンタの種類<!-- omit in toc -->
| 装置  | 説明 |
| ---- | ---- |
| ドットインパクトプリンタ | 印字ヘッドに多数のピンが内蔵され、このピンでインクリボンを打ち付け印字するプリンタ、印字品質は高くない |
| インクジェットプリンタ | 印字ヘッドノズルより用紙に直接インクを吹き付け印刷するプリンタ、高速である |
| レーザプリンタ | レーザ光線を照射することで感光体に印刷イメージを作成しそこに付着したトナーを紙に転写することで印刷するプリンタ、主にビジネス用 |

##### プリンタの性能指標<!-- omit in toc -->
**プリンタの解像度**
プリンタの解像度は1inchあたりのドット数を示す**dpi**を用いて表されます。

**プリンタの印刷速度**
プリンタの印字速度は一秒間に何文字印字できるかを示す**cps**と一秒間に何ページ印刷できるかを示す**ppm**の2つがある。

#### 1.2.5.4. 入出力インターフェス
コンピュータの入出力インターフェスにはさまざまあり、最もポピュラーなのはUSBである。
USBでは繋ぐと自動で設定が行われる**プラグアンドプレイ**という仕組みが使われます。

<img src="https://xtech.nikkei.com/it/pc/article/basic/20101026/1028162/3_px400.jpg" width="60%">

##### パラレル(並列)とシリアル(直列)<!-- omit in toc -->
入出力インターフェスはデータの転送方式によりパラレルインターフェスとシリアルインターフェスに分かれます。
<img src="https://i.ytimg.com/vi/0ZJSFiTJ7XE/maxresdefault.jpg" width="80%">

##### パラレルインターフェス<!-- omit in toc -->
パラレルインターフェスの規格には**IDEやSCSI**が上げられます。

###### IDE<!-- omit in toc -->
内蔵ハードディスクを接続するために規格として使われていたインターフェスである。
元々は最大2台までのハードディスクを接続できるという規格であったが、CD-ROMなどの接続も対応した**EIDE**として拡張された。
EIDEでは最大4台までの機器を接続が可能です。

###### SCSI<!-- omit in toc -->
ハードディスクやCD-ROM、MOドライブやイメージスキャナなどの様々な周辺機器の接続に使われていたインターフェス。
**デイジーチェーン**と呼ばれる数珠つなぎに機器を説ぞk数る方式をとる。また終端にはターミネータ(終端末抵抗)が必要である。
接続できるのはコンピュータ本体含め最大8台までである。また識別のために機器にID番号を割り当てる。

##### シリアルインターフェス<!-- omit in toc -->
シリアルインターフェスの代表規格には**USBやIEEE1394**がある。
この2つは電源を入れたまま抜き差し可能な**ホットプラグ**と周辺機器につなぐと自動設定する**ラグアンドプレイ**に対応している。

##### USB<!-- omit in toc -->
パソコンと各機器を繋ぐ際のもっとも一般的なインターフェスである。
USBハブを通してツリー状に接続されます。またUSBには複数の規格があります。

<img src="https://cdn-xtech.nikkei.com/atcl/nxt/column/18/01049/110500003/2-1.png?__scale=w:800,h:282&_sh=0810f10d60" width="60%">

###### IEEE1394<!-- omit in toc -->
i.LinkやFireWireという名前でも呼ばれ、ハードディスクレコーダなどの情報家電、ビデオカメラなどの機器に使われるインターフェス。
リピータハブを用いてツリー状の接続やディジーチェーン方式での接続が可能。

#### 1.2.5.5. 無線インターフェス
無線で通信するタイプのインターフェスには**IrDAとBlueTooth**がある。

##### IrDA<!-- omit in toc -->
赤外線を用いて無線通信を行う規格であり、携帯電話やノートPC等に使われています。
なおテレビのリモコンは同じく赤外線を用いますがIrDAではありません。
また、障害物があると通信できない特徴があります。

##### BlueTooth<!-- omit in toc -->
2.4GHz帯の電波を用いて無線通信を行う規格であり、コードレスイヤホンや携帯電話、マウスなど様々な周辺機器をワイヤレスに接続可能です。
通信距離は10mほどであり、障害物があっても関係がない。

---
# 2. ソフトウェアとマルチメディア
## 2.1. 基本ソフトウェア
### 2.1.1. OSのタスク
OSはコンピュータの基本動作を実現する基本ソフトウェアである。
#### ソフトウェアの分類
<img src="http://kubota01.my.coocan.jp/extra/image/Operating_System.jpg" width="60%">

#### 2.1.1.1. 基本ソフトウェアのプログラム
基本ソフトウェアは3つのプログラムに分けられる。
* 基本ソフトウェア
   * 制御プログラム ・・・ ハードウェアを管理しコンピュータを効率管理できるように働くソフトウェア
   * 言語処理プログラム ・・・ C言語、Javaなどのプログラム言語で書かれたプログラムを機械語に翻訳するプログラム
   * サービスプログラム ・・・ コンピュータの機能を補う補助的なプログラムでユーティリティと呼ばれ、ファイル圧縮プログラムなどがある

#### 2.1.1.2. 代表的なOS
| 種類  | 説明 |
| ---- | ---- |
| Windows | Microsoft社製のOS、GUIによる画面操作でコンピュータに命令を行う |
| Mac OS | Apple社製のクリエイティブな作業によく用いられるOS、GUIを先駆けで導入したことで有名 |
| MS-DOS | Windows普及前に使われていたMicrosoft社製のOSであり、CUI入力であったことで有名 |
| UNIX | サーバに使われることが多いOS、大勢のユーザが同時利用できるように考えられている |
| LINUX | UNIX互換のOSであり、オープンソースで無償で利用可能 |

#### 2.1.1.3. OSの操作性(GUI/CUI)
コンピュータを操作するインターフェスとして**GUIとCUI**があります。
GUIは画面を視覚的に操作することで命令を伝える操作方式でCUIはコマンドで操作する方式です。

#### 2.1.1.4. API(Application Program Interface)
APIはOSが含み持つ各機能をアプリケーションから呼び出せる仕組みである、

#### 2.1.1.5. ソフトウェアによる自動化(RPA)
ソフトウェアによる自動化にRPA(Robotic Process Automation)があります。

### 2.1.2. ジョブ管理
ユーザからみて処理させたい一連の作業のかたまり単位が**ジョブ**であり、OSはそれを効率よく処理していけるように実行スケジュールを管理します。
ジョブ管理には**バッチ処理**と呼ばれる処理に時間のかかる作業をコンピュータに登録しまとめて処理する仕組みがあります。

#### ジョブ管理フロー<!-- omit in toc -->
ジョブ管理はカーネルが持つ機能の1つであり、この機能でユーザとの間に橋渡しを行う**マスタスケジューラ**という管理プログラムがあります。
ユーザはこの管理プログラムにジョブの実行を依頼する。
また、マスタスケジューラはジョブの実行を**ジョブスケジューラ**に依頼し、マスタスケジューラは実行の監視に努め、ジョブスケジューラがジョブを実行する。
<img src="http://www.it-shikaku.jp/kougi/e/job2.gif" width="60%">

#### スプーリング<!-- omit in toc -->
CPUと入出力装置には処理速度に大きな差が存在する。
**スプーリング**と呼ばれる、低速な装置とのデータやり取りを高速な磁気ディスクを介して行い処理効率を高める手法が導入されている。
スプーリングを用いるとCPUの待ち時間を削減できるため、単位時間あたりに処理できる仕事量を増やすことが可能。

### 2.1.3. タスク管理
コンピュータから見た仕事の単位がタスクである。

#### タスクの状態遷移<!-- omit in toc -->
生成されたタスクの状態には3つの状態があります。
* 実行可能状態(Ready) ・・・ いつでも実行可能でCPUの使用権が回るのを待機する状態、生成直後のタスクは待ち行列になりこの状態となる
* 実行状態(Run) ・・・ CPUの使用権が与えられ実行中の状態
* 待機状態(Wait) ・・・ 入出力処理が発生したので終了を待っている状態

<img src="https://jpeducom.co.jp/FE18b-am/h18b-29k.gif" width="60%">

#### ディスパッチャとタスクスケジューリング<!-- omit in toc -->
実行可能状態で待機するタスクにCPUの使用権を割り当てるのは**ディスパッチャ**と呼ばれる管理プログラムである。
また、このときどのタスクに使用権を割り当てるかを決めるためにタスクの実行順序を定める必要がある。これは**タスクスケジューリング**と呼ばれる。
タスクスケジューリングの種類には3つの方式がある。

##### 到着順序方式<!-- omit in toc -->
実行可能となったタスク順にCPUの使用権を割り当てる方式。
タスクに優先順位がないため、実行途中でCPUの使用権が奪われることはない(**ノンプリエンプション**)

##### 優先式方式<!-- omit in toc -->
タスクに優先度を設定し、優先度が高いものから実行していく方式。
実行中のタスクよりも優先度が高いものが待ち行列に追加されると実行途中でCPUの使用権が奪われる(**プリエンプション**)

##### ラウンドロビン方式<!-- omit in toc -->
CPUの使用権を一定時間ごとに切り替える方式。
実行可能状態になった順番でタスクにCPU使用権が割り当てられるが、規定時間に終わらなかった場合は待ち行列の最後に回されます。

#### マルチプログラミング<!-- omit in toc -->
タスク管理の役割はCPUの有効活用によります。
マルチプログラミングは複数のプログラムを見かけ上同時に実行させることにより遊休時間を削減しCPuの使用効率を高めるものである。

#### 割り込み処理<!-- omit in toc -->
実行中のタスクを中断し別の処理に切り替え、そちらが終了すると再び元のタスクに再帰する処理は**割り込み処理**と呼ばれる。
割り込み処理には下記のような種類があります。

**内部割込み**
| 種類  | 説明 |
| ---- | ---- |
| プログラム割込み | 記憶保護例外などの場合に生じる割り込み |
| SVC割り込み | 入出力処理の要求などのカーネル呼出し命令が生じた際に生じる割り込み |

**外部割込み**
| 種類  | 説明 |
| ---- | ---- |
| 入出力割込み | 入出力装置の動作完了時や中断時に生じる割り込み |
| 機械チェック割込み | 電源異常や主記憶装置障害などのハードウェアの異常時に生じる割り込み |
| コンソール割込み | ユーザによる介入が行われた際に生じる割り込み |
| タイマ割込み | 規定の時間を過ぎたときに生じる割り込み |

### 2.1.4. 実記憶管理
限られた主記憶空間を効率よく使われるようにプログラムに割り当てるのが実記憶管理の役割です。
ノイマン型コンピュータではプログラム内蔵方式をとります。この方式では主記憶上にプログラムをロードして実行します。
プログラムをロードしたときの割り当て方が不適切であると容量は活用できなくなる。そこで適切に書き込むための方法がいくつか存在する。

#### 固定区画方式<!-- omit in toc -->
固定区画方式は主記憶に固定長の区画(**パーティション**)を設けて、そこにプログラムを読み込む管理方式です。
全体を単一の区画とする**単一区画方式**と複数の区画に分ける**多重区画方式**があります。

<img src="https://itmanabi.com/wp-content/uploads/2020/05/b3efa1e86417ccf79236301c3433895b.png" width="60%">

#### 可変区画方式<!-- omit in toc -->
主記憶を最初に固定用で区切るのではなく、プログラムをロードするタイミングで必要なサイズに区切る管理方式が**可変区画方式**である。
この方式ではプログラムが必要とする大きさで区切りを作りそこのプログラムをロードする。また固定区画方式よりも主記憶の利用効率は良い。

<img src="https://itmanabi.com/wp-content/uploads/2020/05/4097ad622ed0ebf3c815d20821379ad5.png" width="90%">

#### フラグメンテーションとメモリコンパクション<!-- omit in toc -->
可変区画方式の場合プログラムを主記憶上に隙間なく埋め込んで実行するとができますが、必ず詰め込んだ順番にプログラムが終了するとは限らないため連続した状態で主記憶の空き容量を確保することができません。この現象は**フラグメンテーション(断片化)** と呼ばれます。
フラグメンテーションの解消のためにはロードされているプログラムを再配置することにより、細切れ状態の空き領域を連続したひとつの領域する必要があります。この操作は**メモリコンパクション**または**ガーベジコレクション**と呼ばれる。

<img src="https://itmanabi.com/wp-content/uploads/2020/05/627674a31e0ec7fafb4584cff280b5f9.png" width="60%">

#### オーバレイ方式<!-- omit in toc -->
区画を効率よく配置できるようにしても実行したプログラムのサイズが主記憶の容量を超えていたらロードができません。
これを可能にするような工夫が**オーバレイ方式**である。
この方式ではプログラムを**セグメント**という単位に分割しておいて、そのときに必要なセグメントだけを主記憶上にロードして実行されます。

<img src="https://itmanabi.com/wp-content/uploads/2020/05/658ba692ca0b3bf12b0817c59d916901.png" width="80%">

#### スワッピング方式<!-- omit in toc -->
マルチプログラミングの環境では優先度の高いプログラムによる割り込みなどが発生した場合、現在実行中のものをいったん中断させ切り替えるが、このとき優先度の低いプログラムが使っていた主記憶領域の内容を補助記憶装置に丸ごと退避させて空き容量を作る。退避させたプログラムに再びCPUの使用権が与えられるとき、退避させた内容は補助記憶装置から主記憶へロードしなおして、中断箇所から処理を再開する。この2つの処理(スワップアウトとスワップイン)を合わせた処理は**スワッピング**と呼ばれる。この処理が発生すると処理速度が極端に低下する。

<img src="https://itmanabi.com/wp-content/uploads/2020/05/77e34a1c28fef9698877f606d3669868.png" width="60%">

### 2.1.5. プログラムの再配置性と4つの性質
再配置可能プログラムはプログラムがどこにロードしても実行に問題ないプログラムです。

#### 再配置可能(リロケータブル)<!-- omit in toc -->
主記憶上のどこに配置しても実行できるといる性質は再配置可能(リロケータブル)と呼ばれる。
#### 再使用可能(リユーザブル)<!-- omit in toc -->
主記憶上にロードされて処理を終えたプログラムを再ロードすることなく、繰り返し実行できる性質は再使用可能(リユーザブル)と呼ばれる。
#### 再入可能(リエントラント)<!-- omit in toc -->
再ロードすることなく繰り返し実行できる再使用可能なプログラムにおいて、複数のタスクから呼び出しても互いに干渉することなく同時実行できるという性質は再入可能(リエントラント)と呼ばれる。
#### 再帰的(リカーシブ)<!-- omit in toc -->
実行中に自分自身を呼び出すことができる性質は再帰的(リカーシブ)と言います。

### 2.1.6. 仮想記憶管理
仮想記憶は主記憶や補助記憶の存在を隠蔽し、広大なメモリ空間を自由に扱えるようにするものです。
実記憶上の配置のような物理的制約を意識する必要がないのが特徴です。
また仮想アドレスから実アドレスへ変化する処理はメモリ交換ユニット(MMU)が行う。またこの仕組みは**動的アドレス変換機構（DAT)** と呼ばれる。
また仮想記憶に置かれたデータは主記憶装置を超えても補助記憶装置もメモリの一部として扱うことにより主記憶装置よりも大きなサイズの記憶空間を提供できる。

#### ページング方式<!-- omit in toc -->
仮想記憶の実装方式には仮想アドレス空間を**固定長の領域に区切って管理するページング方式**と**可変長の領域に区切って管理するセグメント方式**がある。

ページング方式ではプログラムを**ページ**と呼ばれる単位で分割管理します。現在のOSでは実行に必要なページだけを実記憶に読み込ませる方式が主流である。
またこの方式では仮想記憶と実記憶の対応付けは**ページテーブル**という表により管理され、これにより仮想記憶上と実記憶上のどのページが結びついている確認できる。
補助記憶から実記憶へのページ読み込みは**ページイン**と呼ばれます。またページインしようとしても実記憶がいっぱいの場合いずれかのページを補助記憶に追い出して空きを作る必要があります。実記憶から補助記憶へとページを追い出すことは**ページアウト**と呼ばれます。
実記憶の容量が少ないとページの置き換えをする頻度が高くなりシステム利用効率が極端に低下します。この現象は**スラッシング**と呼ばれます。

#### ページの置き換えアルゴリズム<!-- omit in toc -->
| 方式  | 説明 |
| ---- | ---- |
| FIFO | 最初にページインしたページを追い出し対象にする |
| LIFO | 最後にページインしたページを追い出し対象にする |
| LRU | 最も長い時間参照されていないページを追い出し対象にする |
| LFU | 最も参照回数の少ないページを追い出し対象にする |

#### ページングとスワッピング<!-- omit in toc -->
**スワッピング** ・・・ プロセス単位で領域の出し入れを行う
**ページング** ・・・ ページ単位で領域の出し入れを行う

## 2.2. ファイル管理
### 2.2.1. ファイルの正体
ファイルはデータを一つの集まりとして記録するための単位である。
#### 2.2.1.1. データの種類と代表的なファイル形式
##### テキスト形式<!-- omit in toc -->
文字コードと開業やタブなど一部の制御文字のみで作られるファイル形式
##### CSV形式<!-- omit in toc -->
テキスト形式のファイルの一種で、個々のデータである機種やOSの種類のよらず文字や数字をカンマで区切り行と列を改行で区切ることで表形式のデータを保持することに特化したファイル形式。
##### PDF<!-- omit in toc -->
画像が埋め込まれた書類をコンピュータの機種やOSの種類によらず、元の通りに再現して表示することができる電子文書のファイル形式。
##### 画像用のファイル形式<!-- omit in toc -->
| 種類  | 説明 |
| ---- | ---- |
| BMP | 画像を圧縮せずにそのまま保存するファイル形式 |
| JPEG | 画像圧縮保存形式、フルカラーが扱え圧縮率が高く、不可逆圧縮なため画質が劣化します |
| GIF | 画像圧縮保存形式、可逆圧縮であり、扱える色数が256色という制限がある |
| PNG | 画像圧縮保存形式、フルカラーが扱え可逆圧縮であり画像の劣化もない、圧縮率はJPEGが良い |

##### 音声用のファイル形式<!-- omit in toc -->
| 種類  | 説明 |
| ---- | ---- |
| MP3 | 音声を圧縮し保存する形式、人に聞こえないレベルの音を削減するなどをして不可逆の圧縮を行う |
| WAV | 録音したそのままの状態と同じ音質を保ったファイル形式、非圧縮 |
| MIDI | デジタル楽器の演奏データを保存できるファイル形式 |

##### 動画用のファイル形式<!-- omit in toc -->
| 種類  | 説明 |
| ---- | ---- |
| MPEG | 不可逆圧縮で動画を保存するファイル形式、ビデオCDにはMPEG-1、DVDにはMPEG-2、コンテンツ配信にはMPEG-4が用いられる |
| MP4 | MP4はMPEG4と音声のMP3を結合して格納しているファイルである |

#### 2.2.1.2. マルチメディアデータの圧縮・伸張
画像や音声、動画等のマルチメディアデータはそのままであると膨大なデータ量となる。そのため通常は圧縮技術を用いてデータサイズを小さくし保存されるのが一般的である。
**非可逆圧縮**はデータを間引く形で圧縮したものであり、伸張しても元の同じデータになりません。逆に**可逆圧縮**は伸張したら元のデータに戻すことができます。

### 2.2.2. ディレクトリ
ディレクトリはファイルをグループ化して整理するものであり、補助記憶装置中はディレクトリで管理される。

#### 2.2.2.1. ルートディレクトリとサブディレクトリ
ディレクトリ中にはファイルだけではなく他のディレクトリも入れられる。
補助記憶装置全体に階層構造を持たせて管理することが可能である。

* ルートディレクトリ ・・・ 階層の一番上位に位置するディレクトリ
* サブディレクトリ ・・・ 他のディレクトリに含まれるディレクトリ

#### 2.2.2.2. カレントディレクトリ
コンピュータが現在開いて作業しているディレクトリは**カレントディレクトリ**と呼ばれます。
また、カレントディレクトリの1階層上のディレクトリは**親ディレクトリ**と呼ばれます。

### 2.2.3. ファイルの場所を示す手段
ファイルの場所はファイルパスを用いて示します。このファイルまでの場所を示す経路は**パス**と呼ばれます。
パスにはルートディレクトリからの経路を示す**絶対パス**とカレントディレクトリからの経路を示す**相対パス**が存在します。

#### 2.2.3.1. 絶対パスの表記
1. ルートディレクトリは「/」or「\」で表す
2. ディレクトリの次の階層は「/」or「\」で区分する

#### 2.2.3.2. 相対パスの表記
1. ディレクトリの次の階層は「/」or「\」で区分する
2. カレントディレクトリは「.」で表す
3. 親ディレクトリは「..」で表す

### 2.2.4. 汎用コンピュータにおけるファイルの扱われ方
汎用コンピュータにとってのファイルは一連のデータをまとめたものであり、レコードの集合がファイルである。
汎用コンピュータのOSがどのようにレコードを格納するかを定義づけたファイル構成法をいくつか用意しています。

#### 2.2.4.1. ファイルへのアクセス方法
##### 順次アクセス<!-- omit in toc -->
先頭レコードから順番にアクセスする方法であり、シーケンシャルアクセスと呼ばれる。

##### 直接アクセス<!-- omit in toc -->
任意のレコードに直接アクセスする方法であり、ランダムアクセスと呼ばれる。

##### 動的アクセス<!-- omit in toc -->
順次アクセスと直接アクセスを組み合わせた方法で、任意のレコードに直接アクセスした後以降、順次アクセスで順番に処理する。

#### 2.2.4.2. 順編成ファイル
先頭から順番にレコードを記録していくのが順編成ファイル。もっとも単純な編成法で順次アクセスのみが可能である。

#### 2.2.4.3. 直接編成ファイル<!-- omit in toc -->
レコード中のキーとなる値を利用することで任意のレコードを指定した直接アクセスを可能となる編成法。
**直接アクセス方式と間接アクセス方式**があり、キー値から格納アドレスを求める方法が異なる。

##### 直接アクセス方式<!-- omit in toc -->
キー値の内容をそのまま格納アドレスとして用いる方式。

##### 間接アドレス方式<!-- omit in toc -->
**ハッシュ関数**という計算式によりキー値から格納アドレスを算出して用いる方式。
またハッシュ関数での計算値が一致し異なるレコードが同じアドレスで衝突する現象は**シノニム**と呼ばれそれが起こるレコードはシノニムレコードと呼ばれます。

#### 2.2.4.5. 索引編成ファイル
索引を格納する**索引域**とレコードを格納する**基本データ域**、そこからあふれたレコードを格納する**溢れ域**の3つの領域から構成される。
索引による直接アクセスと先頭からの順次アクセスに対応した編成法である。

#### 2.2.4.6. 区分編成ファイル
メンバと呼ばれる順編成ファイルを複数持ち、それらを格納する**メンバ域**と各メンバのアドレスを管理する**ディレクトリ域**で構成される編成法
これはプログラムやライブラリを保存する用途によく使われます。

---
# 3. データベース
## 3.1. DBMSと関係データベース
DBMSはデータベース管理システムのことであり、データベースの定義や操作制御などの機能を持つミドルウェアである。
データベースには関係型、階層型、ネットワーク型の3州類があり、関係型が現在の主流である。

### 3.1.1. 関係型データベース
関係データベースは表の形でデータを管理するデータベースであり、表で構成されます。
また関係データベースは**リレーショナルデータベース(RDB)** と呼ばれます。
| 種類  | 説明 |
| ---- | ---- |
| 表(テーブル) | 複数のデータを収容する場所 |
| 行(レコード) | 1件分のデータを表す |
| 列(フィールド) | データを構成する項目を表す |

### 3.1.2. データの正規化
関係データベースにおいて蓄積データの重複や矛盾が発生しないように最適化するのが一般的です。
同じ内容を表のあちらこちらに書かないように表を分割するなどすることは**正規化**と呼ばれます。

<img src="https://medium-company.com/wp-content/uploads/2021/01/regularization2.png" width="60%">

### 3.1.3. 関係演算とビュー表
関係演算は表の中から特定の行や列を取り出したり、表と表をくっつけ新しい表を作り出したりする演算のことである。
選択、射影、結合などがある。
* 選択 ・・・ 行を取り出す演算
* 射影 ・・・ 列を取り出す演算
* 結合 ・・・ 表同士を結合する演算

このような演算を行い仮想的に作る一時的な表は**ビュー表**と呼ばれる。

### 3.1.4. スキーマ
スキーマは「概念、要旨」という意味を持ち、データベース構造や使用の定義をするものである。
標準使用されているスキーマにはANSI/X3/SPARC規格は**3層スキーマ構造**をとり、**外部スキーマ、概念スキーマ、内部スキーマ**という3層に定義を分けることでデータの独立性を高める。

<img src="https://image.itmedia.co.jp/ait/articles/1703/01/l_r20_04-01.PNG" width="60%">

## 3.2. 主キーと外部キー
データベースの表には行を識別できるようにキーとなる情報が含まれており、それは**主キー**と呼ばれます。また表同士を関連付けするときの主キーは**外部キー**と呼ばれます。
また複数列を組み合わせて主キーにしたものは**複合キー**と呼ばれます。

## 3.3. 正規化
非正規形(正規化を行っていない元の形の表)を何回か正規化を行い最適化行います。
| 正規化  | 説明 |
| ---- | ---- |
| 非正規形 | 正規化されていない繰り返し部分を持つ表 |
| 第1正規形 | 繰り返し部分を分離させ独立したレコードを持つ表 |
| 第2正規形 | 部分関数従属しているところを切り出した表 |
| 第3正規形 | 主キー以外の列に関数従属している列を切り出した表 |

### 3.3.1. 非正規形の表
非正規型の表は繰り返し部分を持ち、関係データベースで扱えない表の形である。

#### 3.3.1.1. 第1正規形
非正規形の表から繰り返し部分を取り除いたものは第1正規形となる。

また表の形は2次元の表となる。

##### 関数従属と部分関数従属<!-- omit in toc -->
* 関数従属 ・・・ 主キーが決まったとき列が一意に定まる関係
* 部分関数従属 ・・・ 複合キー日舞の項目のみで列の値が一意に定まる関係

<img src="https://i0.wp.com/www.yuuk1es.com/wp-content/uploads/2021/03/20444f28a35f679a42ce8ead282be836.jpg?resize=800%2C360&ssl=1" width="60%">

#### 3.3.1.2. 第2正規形
第1正規形の表から部分関数従属している列を分離した表が第2正規形の表である。

#### 3.3.1.3. 第3正規形
第2正規形の表から主キー以外の列に関数従属している列を分離した表が第3正規形の表である。

## 3.3. SQLによるデータベース操作
SQL(Structured Query Language)はDBMSへ支持を伝えるために用いる言語である。
SQLには表の定義(CREATE)やレコードの挿入(INSERT)、削除(DELETE)、レコードの一部を更新(UPDATE)する命令がある。
これらの命令はスキーマ定義や表の作成を担当する**データ定義言語(DDL)** とデータの抽出や挿入、更新、削除といった操作を担当する**データ操作言語(DML)** に区別できます。

### SELECT文<!-- omit in toc -->
SELECT文の基本書式は以下の通りです。

**SELECT 列名 FROM 表名 WHERE 条件**

##### 特定の列の抽出(射影)<!-- omit in toc -->

**SELECT 列名 FROM 表名**

##### 特定の行の抽出(選択)<!-- omit in toc -->

**SELECT * FROM 表名 WHERE 条件式**

なお条件式には比較演算子や論理演算子を用いる。

##### 表同士の結合(結合)<!-- omit in toc -->

**SELECT * FROM 表名1, 表名2 WHERE 表名1.ID = 表名2.ID**

### ORDER文<!-- omit in toc -->
ORDER文は抽出結果を整列させておきたい場合に用います。
**ORDER BY 列名 ASC(or DESC)**
ASC:昇順、DESC:降順

例)商品表の価格順に商品表を並べる場合
SELECT * FROM 商品表 ORDER BY 単価

### 関数を使った集計<!-- omit in toc -->
SQLにはデータを取り出す際に集計を行う様々な関数が用意されている。
| 関数  | 説明 |
| ---- | ---- |
| MAX(列名) | 列の最大値を求める |
| MIN(列名) | 列の最小値を求める |
| AVG(列名) | 列の平均値を求める |
| SUM(列名) | 列の合計を求める |
| COUNT(＊) | 行数を求める |
| COUNT(列名) | 列の値が入っている行の数を求める |

例)扱う商品の数を取り出す場合
SELECT COUNT(＊) FROM 表

### GROUP文<!-- omit in toc -->
グループ化は特定の列が一致する項目をまとめて1つにすることを指す。
グループ化には以下文を用いる。
**GROUP BY 列名**

#### グループの条件絞り込み<!-- omit in toc -->
グループ化なおかつそこから条件を絞り込む場合は**HAVING**を用います。
**GROUP BY 列名 HAVING 絞り込み条件**

## 3.4. トランザクション管理と排他制御
**トランザクション管理と排他処理**は複数人がデータベースにアクセスし同時変更などをした際にデータ内容に不整合が生じる問題からデータベースを守る処理です。

### 3.4.1. トランザクション
データベースにおいて、一連の処理をひとまとめにしたものは**トランザクション**と呼ばれます。

### 3.4.2. 排他制御
排他制御は処理中のデータをロックし、他の人が読み書きできないようにする機能である。
ロックする方法には**共有ロックと専有ロック**がある。
* 共有ロック ・・・ 各ユーザはデータを読むことはできるが、書き込みができない状態
* 専有ロック ・・・ 他ユーザはデータを読み書きすることができない

また、**デットロック**と呼ばれる現象がロック機能を使いすぎると起こる場合があります。
<img src="https://cloudear.jp/blog/wp-content/uploads/2015/07/deadlock2.png" width="60%">

### 3.4.3. ACID特性
DBMSではトランザクション処理に対して4つの特性(**ACID特性**)が必要とされる。
<img src="https://image.itmedia.co.jp/ait/articles/1703/01/r20_21-01b.jpg" width="60%">

### 3.4.4. ストアドプロシージャ
DBMSにSQL文を1つのプログラムにまとめ保存しておくことは**ストアドプロシージャ**と呼ばれます。
一連の処理が実行される。
また、メリットは以下の通りです。
* ネットワークの負荷削減
* 処理速度の向上

### 3.4.5. データベースの障害管理
データベースは定期的に**バックアップ**を作ったり、更新前後の状態を**ジャーナルファイル**に記録したりし障害の発生に備えます。
バックアップ後の更新は**ジャーナル**と呼ばれるログファイルに更新前の状態と更新後の状態を逐一記録しデータベースの更新履歴を管理するようにする。
障害が発生した際にはこれらのファイルを用いて**ロールバック**や**ロールフォワード**などの障害回復朱里を行い、元の状態に復旧する。

### 3.4.6. コミットとロールバック
データベースでは更新処理をトランザクション単位で管理します。
トランザクションは一連の処理が問題なく完了できたときに、最後にその更新を確定することでデータベースへ更新内容を反映させる。これは**コミット**と呼ばれる。
また、トランザクション処理中に障害が発生し更新に失敗した場合、データベース更新前の状態を**更新前ジャーナル**から取得し、データベースをトランザクション処理直前の状態に戻します。この処理は**ロールバック**と呼ばれます。

### 3.4.7. 分散データベースと2相コミット
物理的に分かれている複数のデータベースを見かけ上1つのデータベースとして扱えるようにしたシステムは**分散データベースシステム**と呼ばれます。
これはトランザクション処理が各サイトにわたり行われるので、全体の同期をとりコミット、ロールバックを取らないと、データの整合性が取れなくなる恐れがある。そのため全サイトに問い合わせを行い、その結果を見てコミット、ロールバックを行う。この処理は**2相コミット**と呼ばれる。

### 3.4.8. ロールフォワード
データベース自体が突然障害に見舞われた場合、バックアップ以降の更新ジャーナルから更新情報を取得し、データベースを障害発生直前の状態に復旧させる一連の処理があります。この処理は**ロールフォワード**と呼ばれます。

---
# 4. ネットワーク
## 4.1. LANとWAN
局所的な狭い範囲のネットワークは**LAN**、LAN同士をつなぐ広域ネットワークは**WAN**と呼ばれます。
### 4.1.1. 通信路の方式とWANの技術
通信路を互いの1本の回線で結ぶ方式は**専用回線方式**と呼ばれます。
また交換機により必要に応じた通信路が確立される方式は**交換方式**と呼ばれます。
交換方式には以下の2種があり現在はパケット交換方式が主流です。
* 回線交換方式 ・・・ 回線自体を交換機が繋ぎ通信路が固定されます
* パケット交換方式 ・・・ パケットという単位分割された通信データを交換機が回線へ送り出すことで通信路を形成する

WANを除いて現在のコンピュータネットワークで用いられるのはほぼパケット交換方式である。
またWANは以下の方式でつながれることが多い。
| 種類  | 説明 |
| ---- | ---- |
| 専用線 | 拠点間を専用線で結ぶもの、高セキュリティだが高価 |
| フレームリレ方式 |パケット交換方式をもとに伝送中の**誤り制御を簡素化し高速化**したもの。データ伝送単位は可変長フレームである |
| ATM交換方式 | パケット交換方式をもとにデータ転送単位を固定長のセル(53バイト)にすることで高速化を目指したもの、伝送遅延は小さい |
| 広域イーサネット | LANで使われるイーサネット技術を用いて接続するもの。高速かつコスト面のメリット大。近年主流の方式 |

### 4.1.2. LANの接続方式(トポロジ)

<img src="https://image.itmedia.co.jp/ait/articles/0803/13/r3CCNA_04_01.gif" width="60%">

### 4.1.3. イーサネット
LANの規格として、最も普及しているのがイーサネット(Ethernet)である。
IEEEにより標準化されいくつかの規格に分かれている。伝送速度の単位である**BPS**は1秒間に送ることのできるデータ量を表す。

<img src="https://userdisk.webry.biglobe.ne.jp/024/342/75/N000/000/000/132326788656013115692_56.JPG" width="60%">

### 4.1.4. イーサネットのアクセス制御方式
イーサネットは**CSMA/CD**方式でアクセス制御を監視しています。

<img src="https://www.infraexpert.com/studygif/ethernet23.gif" width="90%">

### 4.1.5. トークンリングとトークンパッシング
リング型のLANの代表である**トークンリング**はアクセス制御方式に**トークンパッシング**が採用されている。

<img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/743730/cf7c9e9f-d9c9-2451-bb9f-af8f45b3062d.jpeg" width="60%">

### 4.1.6. 無線LAN
物理的なケーブルを用いず、電波を用いて無線で通信を行うLANは**無線LAN**であり、IEEE802.11として規格化されている。
電波が届く範囲であればどこでも繋げられますが、電波は盗聴される恐れがあるため暗号化などのセキュリティ対策が重要である。

### 4.1.7. クライアントとサーバの制御
ネットワークによって複数のコンピュータが組み合わせて動く処理の形態には主に2つの種類があります。
* 集中制御型 ・・・ ホストコンピュータが手中的に処理を行い、他のコンピュータにツリー状などでぶら下がる構成となる
* 分散処理型 ・・・ 複数のコンピュータに負荷を分散させ、それぞれで処理を行うようにした構成となる

#### クライアントサーバシステム<!-- omit in toc -->
集中管理した方がよい資源やサービスを提供する**サーバ**と必要に応じリクエストを行う**クライアント**という2種類のコンピュータで処理を行うシステムである。現在の主流である。

## 4.2. プロコトルとパケット
### 4.2.1. プロコトルとOSI基本参照モデル
コンピュータ同士がやり取りするための規定**プロコトル**と呼ばれます。
またプロコトルはたくさんの種類があり、7階層に分けたものは**OSI基本参照モデル**と呼ばれます。

<img src="https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200314095931.gif" width="60%">

インターネットではTCP/IPというプロコトルが利用されています。
### 4.2.3. ネットワークの伝送速度
ネットワークの伝送にかかる時間は下記式で求まる。
**伝送時間 = データ量 / 回線速度**

## 4.3. ネットワークの構成装置
### 4.3.1. LAN装置とOSI参照モデル

<img src="https://cdn-ak.f.st-hatena.com/images/fotolife/n/nok-0930-ss/20180224/20180224002317.png" width="80%">

### 4.3.2. NIC(Network Interface Card)
NICはコンピュータをネットワークに接続するための拡張カードでありLANボードとも呼ばれます。
役割としてはデータを電気信号に変換しケーブル上に流すことと受け取ることである。
また、IEEEにより規格化された**MACアドレスを**が振られており、世界中で自由重複しない番号で保障される。
MACアドレスは16進数表記で48バイトあり、先頭の24ビットが製造メーカ番号で、後ろの24ビットが製造番号を表す。

### 4.3.3. リピータ
リピータは第1層(物理層)の中継機能を実現する装置である。
ケーブル中を流れる電気信号を増幅し、LANの延長距離を延ばす。
また、ネットワーク中につながっていてデータの流される範囲は**セグメント**であり、1つのセグメントに大量のコンピュータが繋がっている場合、パケット衝突が多発するようになり回線利用効率が低下する。

### 4.3.4. ブリッジ
ブリッジは第2層(データリンク層)の中継機能を実現する装置である。
セグメントの中継役として、流れてきたパケットのMACアドレス情報の確認と他方へのセグメントへパケットを伝送します。
ブリッジから転送される中継パケットはCSMA/CD方式であるため、衝突の発生が抑制されネットワーク使用効率が向上します。

### 4.3.5. ハブ
ハブはLANケーブルのポートを複数持つ集線装置である。
* リピータハブ ・・・ リピータを複数束ねたものであり、パケットは無条件でポートへ流される
* スイッチングハブ ・・・ ブリッジを複数束ねたものであり、パケットは宛先MACアドレスに該当するCPが繋がるポートのみに流される

### 4.3.6. ルータ
ルータは第3層(ネットワーク層)の中継機能を実現する装置である。
異なるネットワーク同士の中継役として、流れてきたパケットのIPアドレスを確認した後最適経路へパケットを転送する。
ルータは経路表(ルーティングテーブル)に基づいて、最適な転送先を選択する。これはルーティングと呼ばれる。

### 4.3.7. ゲートウェイ
ゲートウェイは第4層(トランスポート層))以上で異なるネットワーク間においてプロコトル変換による中継機能を提供する装置である。
ネットワーク間で使われるプロコトルの差異をこの装置が変換することで互いの接続を可能とする。

## 4.4. データの誤り制御
データ誤りはビットがノイズや歪により異なる値となることである。
データや誤りを確実に防ぐ方法はなく、**パリティチェックやCRC(巡回冗長検査)** などの手法により誤りを検出し訂正します。

### パリティチェック<!-- omit in toc -->
パリティチェックでは送信するビット列に対し**パリティビット**と呼ばれる検査用のビットを付加することでデータや誤りを検出します。
特徴として1ビットの誤りを検出することができるだけである。誤り訂正ができないという問題もある。

<img src="https://technical-sequence.com/wp-content/uploads/2020/04/parity1-1.png" width="70%">

* 偶数パリティ ・・・ ビット列中の1の数が偶数になるようにパリティビットをセットする
* 奇数パリティ ・・・ ビット列中の1の数が奇数になるようにパリティビットをセットする

### 水平垂直パリティチェック<!-- omit in toc -->
パリティビットはどの方向に付加するかにより、水平パリティと垂直パリティに分かれる。
**垂直水平パリティチェック**であればどのビット位置が誤りであるか検出することができます。

<img src="https://www.ap-siken.com/kakomon/24_haru/img/05_1.gif" width="90%">

### CRC(巡回冗長検査)<!-- omit in toc -->
**CRC**はビット列を特定の式(生成多項式)で割り、余りをチェック用のデータとして付加する手法。
この方式ではデータ誤り訂正はできないが、連続したビット誤りなどを検出することが可能である。

## 4.5. TCP/IPを用いたネットワーク
TCP/IPは第4層(トランスポート層)のTCPと第3層(ネットワーク層)のIPというプロトコルを組み合わせたものである。インターネットのデフォルトスタンダードとなっている。
### 4.5.1. TCP/IPの中核プロトコル
#### IP<!-- omit in toc -->
IPは経路制御を行い、ネットワーク間のパケット転送を行います。
なおコネクションレス(接続確認をとらない)型の通信であるため、通信品質は第4層プロトコルであるTCPやUDPに依存します。
#### TCP(Transmission Control Protocol)<!-- omit in toc -->
TCPは通信相手とのコネクションを確立してデータを送受信するコネクション型のプロトコルである。
パケット順序や送信エラー時の再送などを制御し、送受信のデータの信頼性を保証する
#### UDP(User Datagram Protocol)<!-- omit in toc -->
UDPは通信相手と事前に接続確認を取らずに一方的にパケットを送り付けるコネクションレス型の通信プロトコルである。信頼性は欠けますが高速であり、映像配信サービスなどのリアルタイム性を重視する用途に適している。

### 4.5.2. IPアドレスの種類
IPアドレスは32ビットで表されるネットワーク上の住所であり、グローバルIPとプライベートIP(ローカルIP)があります。この2つの関係は電話の外線と内線に似ています。
#### グローバルIPアドレス<!-- omit in toc -->
グローバルIPアドレスはインターネットで用いるIPアドレスであり、NIC(Network Information Center)により管理される。
#### プライベートIPアドレス<!-- omit in toc -->
プライベートIPアドレスはLAN内で用いれるIPアドレスであり、LAN内での重複が発生しなければシステム管理者が自由に割り当て可能です。

### 4.5.3. IPアドレスの構成
IPアドレスの内容はネットワークアドレス部とホストアドレス部に分けられ、それぞれの関係は住所と名前に似ています。
* ネットワークアドレス ・・・ どのネットワーク化を示す
* ホストアドレス ・・・ どのコンピュータか示す

### 4.5.6. IPアドレスのクラス
IPアドレスはクラスA、クラスB、クラスCの3クラスに分かれており、それぞれ32ビットの内何ビットをネットワークアドレス部に振るかの規定となっている。
| 区分  | 説明 |
| ---- | ---- |
| クラスA | 0.0.0.0 ～ 127.255.255.255: 大規模ネットワーク用 |
| クラスB |128.0.0.0 ～ 191.255.255.255: 中規模ネットワーク用 |
| クラスC |192.0.0.0 ～ 223.255.255.255: 小規模ネットワーク用 |

### 4.5.7. ブロードキャスト
同一ネットワーク内の全てのホストに一斉に同じデータを送信することは**ブロードキャスト**と呼ばれる。
また特定の一台に送信することは**ユニキャスト**、複数でなお且つ決められた範囲の複数ホストに送信する場合は**マルチキャスト**と呼ばれる。

### 4.5.8. サブネットマスクによるネットワーク分割
小規模ネットワークのクラスCにおいては最大254台のホストを扱えます。そこまでホストがいらず、部門ごとにネットワークを分割するには**サブネットマスク**を用います。

### 4.5.9. MACアドレスとIPアドレスの違い
データの配送はイーサネットが行い、近距離を繋ぐのに用いられるのがMACアドレス、中継はIPアドレスが行います。

<img src="https://medium-company.com/wp-content/uploads/2020/01/arp1.png" width="70%">

### 4.5.10. DHCPの仕組み
**DHCP(Dynamic Host Configuration Protocol)** を用いるとIPアドレスの割り当てと言ったネットワークの設定作業を自動化することができる。

### 4.5.11. NATとIPマスカレード
**NATやIPマスカレード**はプライベートIPをグローバルIPに変換する技術であり、ルータに実装されています。
#### NAT<!-- omit in toc -->
グローバルIPとプライベートIPを対で結び付けて相互に変換を行う。また同時にインターネット接続できるのはグローバルIPの数分のみである。

#### IPマスカレード(NAPT)<!-- omit in toc -->
グローバルIPに複数のプライベートIPを結び付け、一対複数の変換を行う。IPアドレス変換時にポート番号を合わせ書き換えることで、１つのグローバルIPアドレスで複数のコンピュータが同時にインターネットに接続可能。

## 4.6. ドメイン名とDNS
**ドメイン名**はIPアドレスを文字で別名を付けたものである。
「www.yahoo.co.jp」などと記載されます。
ドメイン名とIPアドレスを関連付け管理しているのが**DNSサーバ**であり、ブラウザなどではドメイン名やIPアドレスをDNSサーバに尋ねると、それに応じたIPアドレスやドメイン名が返ります。

## 4.7. ネットワークのサービス
ネットワークの様々なサービスは第5層以降のプロコトルが提供します。
またそれらはプロコトルを処理するサーバにより提供されます。

<img src="https://ascii.jp/img/2009/05/11/839855/l/db38622402d1a231.jpg" width="70%">

## 4.8. サービスの識別(ポート番号)
IPアドレスではコンピュータの識別はできても、そのサーバプログラムに宛てたものかまでは特定できない。
そこでその接続口として**ポート番号**という0~65535までの接続口をプログラム上で用意されます。

## 4.9. WWW(World Wide Web)
WWWは多くの人が用いるサービスであり、「http://~」とアドレスを打ち込んだりして見るサービスです。
このサービスは**WEBブラウザ**を用いて世界中にあるWEBサーバから文字や画像、音声、動画などを得ることができます。
### 4.9.1. Webサーバへのリクエスト

<img src="https://medium-company.com/wp-content/uploads/2020/03/http.png" width="70%">

### 4.9.2 Webページの表示
WebページはHTML(HyperText Markup Language)により記述されている。

### 4.9.3. URLの正体
URL(Uniform Resource Locator)という表記を用います。
<img src="https://itmanabi.com/wp-content/uploads/2018/12/url-relation.png" width="70%">

### 4.9.4. CGI
CGI(Common Gateway Interface)はWebブラウザからの要求に応じ、Webサーバで外部プログラムを実行するために用いる仕組みです。
<img src="https://www.infraexpert.com/studygif/tcpip47b.gif" width="70%">

## 4.10. 電子メール
電子メールはネットワーク上のメールサーバをポスト兼私書箱に見立て、テキストやファイルをやりとりする。
MIME(Multipurpose Internet Mail Extentions)という規格により、メールに様々なファイルを添付できるようになりました。
### 4.10.1. メールアドレス
メールアドレスはユーザ名とドメイン名で構成されます。ユーザ名とドメイン名は@で区切られます。
**例:kitakami@gmail.com**
* ドメイン名 ・・・ 住所にあたる情報
* ユーザ名 ・・・ 名前にあたる情報

#### メール宛先の種類<!-- omit in toc -->
電子メールは目的に応じて3種類の宛先を使い分けできます。
| 種類  | 説明 |
| ---- | ---- |
| TO | 宛先である相手のメールアドレスを記載します |
| CC | 一応見てほしい(返信不要)な相手のメールアドレスを記載します |
| BCC | 他者にわからない状態で一応見てほしい相手のメールアドレスを記載します |

### 4.10.2. SMTP
**SMTP**は電子メールを送信するプロコトルです。
SMTPに対応したサーバはSMTPサーバと呼ばれ、郵便ポストとメールの送信の役割を持ちます。

### 4.10.3. POP
**POP**は電子メールをユーザが受信する際に使われるプロコトルです。
POPに対応したサーバはPOPサーバと呼ばれ、現在はPOP3がよく使われています。

### 4.10.4. IMAP
**IMAP**はPOPと同じく電子メールをユーザが受信する際に使われるプロコトルです。
POPと異なるのは送受信データはサーバで管理されるため、どのコンピュータからでも同じデータを参照できます。

### 4.10.5. MIME
MIMEは日本語などの2バイト文字や画像データなどのファイルの添付を行えるように、電子メールの機能を拡張したものです。
MIMEには暗号化や電子署名の機能を加えた**S/MIME**という規格があります。

### 4.10.6. 電子メールの文字化け
特定のコンピュータでしか表示できない文字は**機種依存文字**と呼ばれます。
メールなどでは機種依存文字の使用は避けられます。

## 4.11. ビッグデータと人工知能
### ビッグデータ<!-- omit in toc -->
ビッグデータはインターネット上に蓄積されていく膨大なディジタルデータである。
このビッグデータは3特性を持ちます。
* Variety(多様性)
* Velocity(頻度)
* Volume(量)

これらの分析は統計的な手段を用いて行われます。
### 人工知能(Artificial Intelligence)<!-- omit in toc -->
人工知能は、人に明確的な定義やプログラミングされた指示がなくても、判断材料をもとに分析・学習することで様々な判断を行えます。
AIの実現するための技術には**機械学習**があります。
また機械学習を発展させたものには**ディープラーニング**があります。
### 機械学習<!-- omit in toc -->
機械学習の学習方法には3つの方法があります。
#### 教師あり学習<!-- omit in toc -->
データに正解や誤りを定義する手法
#### 教師なし学習<!-- omit in toc -->
データのみ与える手法
#### 強化学習<!-- omit in toc -->
行動に対する良しあしを得点として与えることで得点が最も多く得られる方策を学習する手法


# 5. セキュリティ
## 5.1.  ネットワークの脅威
### 5.1.1. セキュリティマネジメントの3要素
情報セキュリティでは3つの要素を管理してうまくバランスさせることが必要とされる。
* 機密性 ・・・ 情報が漏洩しないようにする
* 完全性 ・・・ 情報が書き換えられず完全な状態を保つようにする
* 可用性 ・・・ 利用者が必要なときに必要な情報を使用できるようにする

### 5.1.2. セキュリティポリシ<!-- omit in toc -->
組織としてセキュリティに関してどう取り組むかを周知するものは**セキュリティポリシ**です。
* 基本方針 ・・・ 情報セキュリティに対して組織での基本方針を定める
* 対策基準 ・・・ 基本方針を実現するために行う対策や基準を定める
* 実行手順 ・・・ 日々の業務でどのように実施するか具体的な手順を定める

### 5.1.3. 個人情報保護法とプライバシマーク<!-- omit in toc -->
**個人情報保護法**は個人情報が事業者が適切に扱うためのルールを定めたものです。
個人情報に関する認定制度として**プライバシマーク制度**があります。これはJIS Q 15001に適合して個人情報の適切な保護体制が整備できている事業者を認定するものである。

### 5.1.4. ユーザ認証とアクセス管理
コンピュータシステムの利用にあたりユーザ認証を行うことでセキュリティを保ちます。
ユーザ認証をパスしてシステムを利用可能な状態にすることは**ログイン**、システムの利用を終了しログイン状態を打ち切ることは**ログアウト**と呼ばれます。
#### ユーザ認識の手法<!-- omit in toc -->
##### ユーザIDとパスワードによる認証<!-- omit in toc -->
ユーザIDとパスワードの組み合わせを用いて個人を識別する認識方法である。
##### バイオメトリクス認証<!-- omit in toc -->
指紋や声帯や虹彩などの身体的特徴を使って個人を認証する方法であり、生体認証とも呼ばれます。
##### ワンタイムパスワード<!-- omit in toc -->
一度限り有効な使い捨てのパスワードを用いる認証方法です。
##### コールバック<!-- omit in toc -->
サーバに接続する場合、いったんアクセスした後に回線を切り、逆にサーバからコールバックさせることでアクセス権を確認する認証方法です。

#### アクセス権の設定<!-- omit in toc -->
アクセス権は許可され人が操作できる権利です。操作には「読み取り」「修正」「追加」「削除」などがあります。これをユーザごとに指定します。
#### ソーシャルエンジニアリング<!-- omit in toc -->
ソーシャルエンジニアリングはコンピュータを介さず、人の心理的不注意を用いて情報資産を盗み出すことです。
パスワードの書かれた紙の閲覧や画面の盗み見(ショルダーハッキング)、ゴミ箱から情報を抜き取る(スキャッピング)などがこれにあたります。
#### 不正アクセスの手法<!-- omit in toc -->
| 種類  | 説明 |
| ---- | ---- |
| パスワードリスト攻撃 | どこかから入手したIDとパスワードのリストを用いて他のサイトへのログインを試みる手法 |
| ブルートフォース攻撃 | 特定のIDに対し、パスワードとして使える文字の組み合わせを片っ端から試す手法で、総当たり攻撃と言われます |
| リバースブルートフォースト攻撃 | ブルートフォース攻撃の逆でパスワードが固定でIDを片っ端から試す手法です |
| レインボー攻撃 | ハッシュ値から元のパスワード文字列を解析する手法 |
| SQLインジェクション | ユーザの入力をデータベースに問い合わせ処理を行うWebサイトで悪意あのある問い合わせや操作を行うSQL文を埋め込みデータベースのデータの改ざんや不正取得を行う手法 |
| DNSキャッシュポイズニング | DNSのキャッシュ機能を悪用し偽のドメインを覚えさせることで、偽装サイトへ誘導する手法 |

#### rootkit<!-- omit in toc -->
**rootkit(ルートキット)** は攻撃者が不正アクセスに成功したコンピュータを制御できるようにするソフトウェアの集合です。
rootkitには侵入の痕跡を隠蔽するログ改ざんツールや、リモートからの侵入を簡単にするバックドアツール、改ざんされたシステムツール群などが含まれる。

### 5.1.5. コンピュータウィルスの脅威
コンピュータウィルスは以下の3つの基準のうち1つを満たすとコンピュータウィルスと定義づけられます。(経産省基準)
* 自己伝染機能
* 潜伏機能
* 発病機能

#### コンピュータウィルスの種類<!-- omit in toc -->
| 種類  | 説明 |
| ---- | ---- |
| 狭義のウィルス | 他のプログラムに寄生し、その機能を利用する際に発病するもの |
| マクロウィルス | アプリケーションのもつマクロ機能を悪用したものでデータファイルに寄生し感染を広げる |
| ワーム | 事故単身で複製を生成し、ネットワークを介し感染を広めるものであり作成が容易である |
| トロイの木馬 | 有用なプログラムであるように見せかけて、実行をユーザに促しその裏で不正な処理を行うもの |

**マルウェア**と呼ばれる悪意のあるソフトウェアがあります。これらの種類は以下の通りです
| 種類  | 説明 |
| ---- | ---- |
| スパイウェア | 情報収集を目的としたプログラムで、個人情報を収集し外部に送信する |
| ボット | 感染したコンピュータをボット制作者の指示通りに動かすものである |

#### ウィルス対策ソフトウェアと定義ファイル<!-- omit in toc -->
**ウィルス対策ソフト**はコンピュータに入ったデータをスキャンし、データに問題がないかをチエックします。
ウィルス対策ソフトがウィルスを検出するためには既知のウィルス情報を記した**ウィルス定義ファイル**が必要であり、これを常に最新状態に保つことが重要である。

#### ビヘイビア法(動的ヒューリスティック法)<!-- omit in toc -->
**ビヘイビア法**は実行中のプログラムの挙動を監視して、不審な処理が行われていないか検査する方法であり、未知のウィルスを検出できます。
方法としては監視下で直接実行させて不審な動きがあるプログラムは即座に停止させ、仮想環境でも実行させて危険な行動か監視します。

### 5.1.6. ネットワークのセキュリティ対策
#### 5.1.6.1. ファイヤーウォール
LANの中と外を仕切る役割をするのが**ファイヤーウォール**であり、機能のことを指すため定まったせっえち方法はない。
実現方法には**パケットフィルタリング**や**アプリケーションゲートウェイ**があります。

#### 5.1.6.2. パケットフィルタリング
パケットフィルタリングではパケットのヘッダ情報を見て、通過の可否を判定します。
通常アプリケーションが提供するサービスはプロコトルとポート番号で区別されるため、通過させるサービスを選択することとなる。

#### 5.1.6.3. アプリケーションゲートウェイ
アプリケーションゲートウェイは**プロキシサーバ**とも呼ばれ外部とのやり取りを代行して行う機能である。
通信する側から見るとプロキシサーバしか見えないため、LAN内のコンピュータにが不正アクセスの標的になることを防ぐことができます。
アプリケーションゲートウェイ型のファイヤーウォールには**WAF(Web Application Firewall)** があり、Webアプリケーションに対する外部アクセスを監視するもので、パケットフィルタリングと異なり、通信データの中身までチェックすることで悪意を持った攻撃を検知する。
#### 5.1.6.4. ペネトレーションテスト
**ペネトレーションテスト**は既存手法を用いて実際に攻撃を行い、これによりシステムのセキュリティホールや設定ミスと言った脆弱性の有無を確認するテストです。

### 5.1.7. 暗号化技術とデジタル署名
暗号化とディジタル署名はパケットに鍵をかけるようなものです。
ネットワーク上に潜む危険は以下の3種類があります。
* 盗聴 ・・・ 送信したデータ内容を第3者に盗み読まれる危険性
* 改ざん ・・・ データやり取りは正常に見えるが途中で第3者に書き換えられる危険性
* なりすまし ・・・ 第3者になりすまし、データを送受信できてしまう危険性

#### 暗号化と復号<!-- omit in toc -->
送り手と受け手が同じ鍵を用いる暗号化方式は**共通暗号化方式**または**秘密鍵暗号方式**と呼ばれます。

#### 公開暗号化方式<!-- omit in toc -->
**公開鍵暗号方式**は**公開鍵**という公用の鍵を持ち、公用鍵は公開して暗号化し、複合には秘密鍵を用いる方式です。
共通鍵暗号方式よりも暗号化や復号に大変時間がかかります。

#### ディジタル署名<!-- omit in toc -->
暗号化にはデータ全体を暗号化するのではなく、ハッシュ化という手法で短い要約データ(**メッセージダイジェスト**)を作成しそれを暗号化することでディジタル署名とする。
元データが同じ場合、ハッシュ関数は必ず同じメッセージダイジェストを生成するため、復号結果と受信したデータから新たに取得したメッセージダイジェストを比較して一緒であれば改ざんしていないと言える。

#### CA(Certificate Authority)<!-- omit in toc -->
認証局(**CA**)は公開鍵がその本人のものであるか証明する機関です。
認証局に公開鍵を登録し、登録した鍵によりその身分を保証するという仕組みです。
この認証機関と公開鍵暗号技術を用いて通信の安全性を保証する仕組みは**公開鍵基盤(PKI)** と呼ばれます。

---
# 6. システム/アプリの開発
## 6.1. システム開発フロー
システムは**企画→要件定義→開発→運用→保守**というフェーズでシステムの一生は表せられ**ソフトウェアライフサイクル**と呼ばれます。
### 6.1.1. 開発の大まかなフロー
<img src="https://pm-rasinban.com/wp-content/uploads/2018/08/4598c44bf23abbb471037c4d265a7e1d-1024x767.jpg" width="70%">

### 6.1.2. 要件定義
この工程は作成するシステムにどんな機能が求められているか明らかにします。
要件を取りまとめた結果について**要件定義書**という形で文書に残します。

### 6.1.3. システム設計
要件定義の内容を具体的なシステムの仕様に落とし込む作業です。
システム設計は主に3つの段階に分かれます。
#### 外部設計<!-- omit in toc -->
「利用者から見た」設計を行います。ユーザインターフェスなどの利用者が直接手を触れる部分の設計を行う。
#### 内部設計<!-- omit in toc -->
「開発者から見た」設計を行います。外部設計を実現s塗るための実装方法やデータ設計などを行います。
#### プログラム設計<!-- omit in toc -->
プログラムをどう作るかという視点で設計を行います。プログラムの構造化設計やモジュール同士のインターフェス仕様がこれにあたります。

### 6.1.4. テスト
#### 6.1.4.1. 単体テスト
モジュールレベルの動作確認を行います。
#### 6.1.4.2. 結合テスト
モジュールを結合させた状態で動作確認や入出力の検査を行います。
#### 6.1.4.3. システムテスト
システム全体を稼働させて動作確認や負荷試験などを行います。
#### 6.1.4.4. 運用テスト
実際の運用と同じ条件下で動作確認を行います。

## 6.2. システム開発手法
<img src="https://kogasoftware.com/wordpress/wp-content/uploads/2015/06/agile_scrum_31.png" width="70%">

### 6.2.1. ウォータフォールモデル<!-- omit in toc -->
<img src="https://static.it-trend.jp/article/img/process_management_464-0012_1.png" width="70%">

### 6.2.2. プロトタイピングモデル<!-- omit in toc -->
<img src="https://medium-company.com/wp-content/uploads/2019/03/prot02.png" width="70%">

### 6.2.3. スパイラルモデル<!-- omit in toc -->
<img src="https://medium-company.com/wp-content/uploads/2019/03/supa01.png" width="70%">

## 6.3. CASEツール<!-- omit in toc -->
CASEはコンピュータ支援ソフトウェア工学という意味です。CASEツールはシステム開発を支援するツールです。
開発に関する情報は**リポジトリ**というデータベースで管理します。

## 6.3. システム開発手法2
### 6.3.1. RAD(Rapid Application Development)
**RAD**は迅速なアプリケーション開発という意味であり、エンドユーザと開発者による少数構成のチームを組み、開発支援ツールを活用するなどして、とにかく短期間で開発することを重要視した開発手法です。
RADツールとして有名なのはVIsual Basicのビジュアル開発環境などが該当します。
RADではプロトタイプを作成しそれを評価するサイクルを繰り返すことで完成度を高めます。このフェーズが無限に繰り返されないように開発の期限を設けます。これは**タイムボックス**と呼ばれます。

### 6.3.2. アジャイル開発とXP(extreme Programming)
**アジャイル開発**はスパイラルモデルの派生型であり、より短い反復単位を用いて迅速に開発を行う手法である。この開発手法では1つの反復で1つの機能を開発し、反復を終えた時点で機能追加されたソフトウェアをリリースします。
アジャイル開発の一種である**XP**は少人数の開発に適用しやすいとされ、既存の開発手法が仕様を固めて行う方式であったのに対し、XPは変更を許容する柔軟性を実現します。
XPでは5つの価値と19のプラクティスが定義されており、そのうち開発プラクティスとして定められているのは以下6つである。

| プラクティス  | 説明 |
| ---- | ---- |
| **テスト駆動開発** | 実装前にテストを定め、テストをパスするように実装を行う。テストは自動テストであることが望まれる |
| **ペアプログラミング** | 2人1組でプログラミングを行う。1人がコードを書きもう1人がコードの検証役になり、互いの役割を入れ替えながら作業を進める |
| **リファクタリング** | 完成したプログラムでも内部のコードを随時改造する。冗長コードを改めるに留める。 |
| ソースコードの共有所有 | コードの制作者に断りなく、チーム内の誰もが修正を行うことができる。チーム全員がコードの責任を負う |
| 継続的インテグレーション | 単体テストを終えたプログラムはすぐに結合し結合テストを行う |
| YAGNI | 今必要とされるシンプル機能だけの実装に留める |

### 6.3.3. リバースエンジニアリング
**リバースエンジニアリング**は既存のソフトウェアの動作を解析することで、プログラムの仕様やソースコードを導き出す手法。
目的は既にあるソフトウェアを再利用することで、新規開発を手助けすることである。
これによって得られた仕様をもとに新しいソフトウェアを開発する手法は**フォワードエンジニアリング**と言う。
フォワードエンジニアリングはオブジェクトコードを**逆コンパイル**してソースコードを取り出したりします。
これを元となるソフトウェア権利者の許諾なく行うと知的財産権の侵害にあたるため注意が必要である。

### 6.3.4. マッシュアップ
公開されている複数のサービスを組み合わせることにより新しいサービスを作り出す手法は**マッシュアップ**と呼ばれます。

## 6.4. 業務のモデル化
モデル化は現状のプロセスを抽象化し視覚的に表すことであり、システムが実現すべき機能の洗い出しのために行われます。
代表的なものに**DEF**と**ER図**があります。

### 6.4.1. DED(Data Flow Diagram)
DEFはデータの流れを図として表したものです。
<img src="https://itmanabi.com/wp-content/uploads/2021/03/DFD-mark.png" width="70%">

DFDの例
<img src="https://cacoo.com/wp-app/uploads/sites/2/2020/03/DFD%E3%83%86%E3%82%99%E3%83%BC%E3%82%BF%E3%83%95%E3%83%AD%E3%83%BC%E5%9B%B3%E3%81%AE%E8%A8%98%E8%BC%89%E4%BE%8B.png" width="70%">

### 6.4.2. ER図(Entity-Relationship)
ER図は**実体**と**関係**という概念を用いてデータ構造を図に表したものである。
<img src="https://astah.change-vision.com/ja/Resources/Images/manual/erd/erd-sample.png" width="40%">

## 6.5. ユーザインターフェス(UI)
### 6.5.1. CUIとGUI
**CUI**は文字を打ち込むことでコンピュータに命令を伝えて処理させる方式です。マウスなどは一切用いません。
**GUI**は画面にアイコンやボタンを表示してそれをマウスなどのデバイスで操作し命令を伝えるグラフィカルな操作方式であり現在の主流である。

### 6.5.2. GUIで用いられる部品
| 部品  | 説明 |
| ---- | ---- |
| メニューバ | アプリケーションの基本領域であり、ここに各コンポーネントが配置されます |
| ウィンドウ | アプリケーションを操作するための項目が並んだメニュー |
| プルダウンメニュ | クリックすると垂れ下がり表示されるメニュー |
| テキストボックス | 文字入力用の短形領域である |
| チェックボックス | 選択肢を複数選択したり特定の項目をON/OFFさせる用途に用いられる |
| ラジオボタン | 複数ある選択肢から1つだけを選ばせるのに用いる |

## 6.6. コード設計と入力チェック
### コード設計のポイント<!-- omit in toc -->
コード設計で定めたルールは運用開始後に変更することが難しくなります。そのため将来的に扱うデータ量や将来予測を行い、適切な桁数や割り当て規則を定める必要がある。
入力ミスや読み取りミスを検出する方法に**チェックディジット**を使用する方法があります。

### チェックディジット<!-- omit in toc -->
**チェックディジット**は誤入力を判定するためにコードへ付加された数字のことである。
<img src="https://president.ismcdn.jp/mwimgs/4/1/568/img_411d7b93de7e5b16fc607121ad5bbd5573798.jpg" width="40%">

### 入力ミスを判定するチェック方法<!-- omit in toc -->
| チェック方法  | 説明 |
| ---- | ---- |
| ニューメリックチェック | 数値として扱う必要のあるデータに文字など数値として扱えないものが含まれていないかチェックします |
| シーケンスチェック | 対象とするデータが一定の順序で並んでいるかをチェックする |
| リミットチェック | データが適切な範囲内にあるかチェックします |
| フォーマットチェック | データの形式が正しいかチェックします |
| 照合チェック | 入力されたコードが表中に登録されているかチェックします |
| 論理チェック | 販売数と在庫数と仕入れ数関係なく対となる項目の値に矛盾がないかチェックします |
| 重複チェック | 一意であるべきコードなどが重複して複数個登録されていないかチェックします |

## 6.7. モジュール分割
各プログラムをモジュール単位に分解・階層化させることは**プログラムの構造化設計**と言います。
シンプルで保守性に優れたプログラムを作るための構造化設計のためのモジュール分割法には「データの流れに注目した技法」と「データの構造に注目した技法」があります。

### モジュール分けの利点と留意点<!-- omit in toc -->
モジュール分けのメリットとして以下のような点があげられます。
* 作業の分担が可能
* 再利用が簡単
* 修正が一部で済む

モジュール分けした後の作業は3つの制御構造を用いてプログラミングする**構造化プログラミング**へと移ります。

### モジュール分割技法<!-- omit in toc -->
「データの流れ」に着目した技法は以下の3種類です。

##### STS分割法<!-- omit in toc -->
**入力処理**、**変換処理**、**出力処理**という3つのモジュール構造に分割する手法

##### トランザクション分割法<!-- omit in toc -->
プログラムを一連の処理(トランザクション)単位に分割する方法

##### 共通機能分割法<!-- omit in toc -->
プログラム中の共通機能をモジュール分割する方法

#### モジュール独立性を測る尺度<!-- omit in toc -->
モジュールの独立性を測る尺度として用いられるのは**モジュール強度**と**モジュール結合度**です。

##### モジュール強度<!-- omit in toc -->
<img src="https://itmanabi.com/wp-content/uploads/2021/02/module-strength-800x311.png" width="80%">

##### モジュール結合度<!-- omit in toc -->
<img src="https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200802214034.gif" width="80%">

## 6.8. テスト
### 6.8.1. テストの流れ
#### 6.8.1.1. 単体テスト
単体テストでは各モジュールごとにテストを個なって誤りがないかを検証します。この手法では**ブラックボックステスト**や**ホワイトボックステスト**という手法を用いて検証を行います。

#### 6.8.1.2. 結合テスト
結合テストでは複数のモジュールを繋ぎ合わせて検証を行い、モジュール間のインターフェスが正常に機能しているかを確認します。

#### 6.8.1.3. システムテスト
システムテストはさらに検証の範囲を広げてシステム全体のテストを行う。
* 機能テスト ・・・ 要求された機能がちゃんと動くのか確認する
* 性能テスト ・・・ 処理能力は十分か確認する
* 負荷テスト ・・・ 高い負荷の下でも問題ないかを確認する

テストの流れは以下の通りです。
**単体テスト→結合テスト→システムテスト**

### 6.8.2. ブラックボックステストとホワイトボックステスト
#### 6.8.2.1. ブラックボックステスト
モジュールの内部構造は意識せず入力に対して適切な出力が仕様通りに得られるかを確認します。
#### 6.8.2.2. ホワイトボックステスト
モジュール内部構造が正しく作られているかを検証します。入出力は構造をテストするためだけに過ぎない。

### 6.8.3. テストデータの決めごと
ブラックボックステストを行うさいに入力値をしっかり定義づけることが大切です。その入力テストデータを作成する基準として用いらるのは**同値分割**と**限界値分析**である。
#### 同値分割<!-- omit in toc -->
データ範囲を種類ごとのグループに分け、それぞれから代表的な値を抜き出してテストデータとして用います。
#### 限界値分析<!-- omit in toc -->
限界値分析では上記グループの境目部分を重点的にチェックします。境界前後の値をテストデータに用い、境界値分析と言います。

### 6.8.4. ホワイトボックステストの網羅基準
ホワイトボックステストを行うにあたって、どこまでのテストパターンを網羅するか定めた上でテストケースを設計します。

<img src="http://my-web-site.iobb.net/~yuki/wp-content/uploads/1981/03/1981_test09_WhiteBox.jpg" width="70%">

### 6.8.5. トップダウンテストとボトムアップテスト
#### トップダウンテスト<!-- omit in toc -->
上位モジュールから先にテストを済ませていく方式。
未テストの下位モジュールは**スタブ**と呼ばれ仮のインターフェスとつなげ確認します。

#### ボトムアップテスト<!-- omit in toc -->
下位モジュールからテストを行う方式。
**ドライバ**と呼ばれる仮のモジュールをくっつけインターフェスの確認を行います。

#### その他のテスト<!-- omit in toc -->
トップダウンテストとボトムアップテストを組み合わせて行う**折衷テスト**やすべてのモジュールを一気につなげる**ビッグバンテスト**がある。

### 6.8.6. リグレッションテスト
**リグレッションテスト(退行テスト)** はプログラムを修正した時にその修正内容が正常に動作していた部分まで悪影響を与えていないかを確認するテストです。

### 6.8.7. バグ管理図と信頼度成長曲線
テスト終了、品質向上の十分性を判断する指標として**バグ管理図**があります。
<img src="https://www.fe-siken.com/kakomon/17_haru/img/45.gif" width="40%">

### 6.8.8. システム周りのマネジメント
#### プロジェクトマネジメント<!-- omit in toc -->
開発プロジェクトの技法を体系的にまとめたものに**PMBOK(Project Management Body of System)** があります。PMBOKは米国のプロジェクトマネージメント協会が規格化した知識体系で国際標準化されています。
<img src="http://www.consulting-skill.com/img/clipimage_25.jpg" width="60%">

#### WBS(Work Breakdown Structure)<!-- omit in toc -->
**WBS**はプロジェクトに必要な作業や成果物を階層化した図で表すものであり、PMBOKのスコープ管理に用いられます。

#### 開発コストの見積り<!-- omit in toc -->
システムの開発の見積もり方法には以下のようなものがあります。
##### プログラムステップ法<!-- omit in toc -->
従来の手法で、ソースコードの行(ステップ)数により開発コストを算出する手法
##### ファンクションポイント法<!-- omit in toc -->
標準画面、印刷する帳票、出力ファイルなどユーザから見える機能に着目し、その個数や難易度から開発コストを算出する方法

### 6.9.9. スケジュール管理とアローダイアグラム
システム開発のスケジュール管理には**ガントチャート**や**アローダイアグラム**などが活用されます。
#### アローダイアグラム<!-- omit in toc -->
<img src="http://www.pursue.ne.jp/jouhousyo/sysadPERT/ImageQ/sysQ01_01.gif" width="70%">

#### スケジュール短縮のために用いる手法<!-- omit in toc -->
スケジュール短縮のために用いる代表的手法が**クラッシングとファストトラックキング**の2つがある。
##### クラッシング<!-- omit in toc -->
クラッシングは資源を追加投入してコストの増大を最小限に抑えながらスケジュールの所要時間を短縮する技法である。
##### ファストトラックキング<!-- omit in toc -->
ファストトラックキングとは通常は順番に実施させるアクティビティやフェーズを並行して逐行するスケジュール短縮法である

### 6.6.10. ITサービスマネジメント
ITサービスを提供するにあたっての管理・運用規則に関するベストプラクティスが体系的にまとめられました**ITIL**と呼ばれます。
ITILは大きく分けて**サービスサポート**と**サービスデリバリ**の2つにより拘束されます。

#### SLA(Service Level Agreement)<!-- omit in toc -->
サービスレベルアグリーメント(SLA)は**サービスレベル合意書**であり、サービスの利用者と提供者の間で「どのようなサービスをどういった品質で提供するか」を取り決めて明文化したものである。
設定した目標を達成するために、計画-実行-確認-改善というPDCAサイクルを構築し、サービス水準の維持・向上に努める活動は**サービスレベルマネージメント(SLM)** と呼ばれる。

#### サービスサポート<!-- omit in toc -->
サービスサポートは1つの機能と5つの業務プロセスにより構成されます。
<img src="https://image.itmedia.co.jp/enterprise/articles/0709/19/l_itil2.jpg" width="70%">

### 6.6.11. サービスデスクの組織構造
#### ローカル・サービスデスク<!-- omit in toc -->
ユーザの拠点内、もしくは物理的に近い場所に設けられたサービスデスクである。

#### 中央サービスデスク<!-- omit in toc -->
1か所に窓口を集約させたサービスデスクである。

#### バーチャル・サービスデスク<!-- omit in toc -->
インターネットなどの通信技術を利用することで、実際には各地に分散しているスタッフを疑似的に1か所で対応しているように見せかけるサービスデスクである。

#### サービスデリバリ<!-- omit in toc -->
ITILの中で長期視点でITサービスの計画と改善を図ることはサービスデリバリは5つの業務プロセスにより構成されます。

<img src="https://image.itmedia.co.jp/enterprise/articles/0709/19/itil3.jpg" width="70%">

#### ファシリティマネジメント<!-- omit in toc -->
**ファシリティマネジメント**はサーバなどに設備を適切に管理・改善する取り組みのことで施設管理と呼ばれます。
**UPS**は無停電電源装置と呼ばれ、外付けバッテリのような使い方のできる装置である。

### 6.6.12. システム監査
**ITガバナンス**は組織がITに関するすべての活動、成果及び関係者を適正に統一し、目指すべき姿へと導くための仕組みを組み込むことである。
#### システム監査人と依頼者・被監査部門の関係<!-- omit in toc -->
システム監査人には次の要素が求められます。
* 外見上の独立性
* 精神上の独立性
* 職業倫理と誠実性
* 専門能力

#### システム監査の手順<!-- omit in toc -->
##### 監査計画の立案<!-- omit in toc -->
↓
##### 予備調査<!-- omit in toc -->
↓
##### 本調査<!-- omit in toc -->
↓
##### 評価・結論<!-- omit in toc -->

#### システムの可監査性<!-- omit in toc -->
**可監査性**は処理の正当性や内部統制を効果的に監査、レビューできるようにシステムが設計運用されていることである。
またシステムにおける事象発生から最終結果に至るまでの一連の流れを時系列に沿った形で追跡できる仕組みは**監査証跡**と呼ばれます。

#### 監査報告とフォローアップ<!-- omit in toc -->
監査意見には**保証意見**と**助言意見**の2種類があります。
またシステム監査人が行う改善指導は**フォローアップ**と呼ばれます。


# 7.プログラムの作り方
## 7.1. プログラミング言語
### 7.1.1. 代表的な言語とその特徴
#### C言語<!-- omit in toc -->

OSやアプリケーションなど広範囲で用いられる言語です。ハードウェアに近いレベルの記述までもできます。
#### BASIC<!-- omit in toc -->

古くから使われていた言語です。インタプリタ方式で主流である特徴を持つ、動作確認しながら開発を進められる。
#### COBOL<!-- omit in toc -->

事務処理用に古くから使われています。システム改修などでまだ使われている言語です。

#### Java<!-- omit in toc -->

オブジェクト指向やネットワーク機能が想定されて設計されています。Java仮想マシンという環境を用いることでOSやコンピュータによらず作成したプログラムを動かすことができます。

### 7.1.2. インタプリタとコンパイラ
#### インタプリタ方式<!-- omit in toc -->
ソースコードに書かれた命令を１つずつ機械語に翻訳しながら実行します。逐次翻訳するため動作を確認しながら作っていくことが容易に行えます。
#### コンパイラ方式<!-- omit in toc -->
ソースコードの内容を最初に全て機械語に翻訳します。作成途中で確認のため動かすと言った手法は用いれません。

## 7.2. コンパイラ方式でのプログラムの実行手順
コンパイラ方式のプログラムの場合、その過程でコンパイラ以外に**リンカとローダ**が使われます。

### コンパイラの仕事<!-- omit in toc -->
<img src="https://www.gadgety.net/shin/tips/images/compiler/phase.gif" width="70%">

### リンカの仕事<!-- omit in toc -->
プログラムは自分で分割したモジュールやライブラリとしてあらかじめ提供されている関数や共通モジュールなどすべてつなぎ合わせる作業は**リンク(連係編集)** と呼ばれます。これがリンカの仕事です。
あらかじめリンクさせておく手法は**静的リンキング**と呼ばれます。またこの時点ではリンクさせず、プログラムの実行時にロードしてリンクする手法は**動的リンキング**と呼ばれます。

### ローダの仕事<!-- omit in toc -->
ロードモジュールを主記憶装置に読み込ませる作業は**ロード**と呼ばれます。これを担当するプログラムがローダである。

## 7.3. 構造化プログラミング
**構造化プログラミング**はプログラムを機能単位の部品に分けて、その組み合わせで全体を形作るプログラミングです。

### 制御構造として用いる3つの原則<!-- omit in toc -->
構造化プログラミングでは原則的に3つの制御構造を使ってプログラミングを行います。
* 順次構造 ・・・ 上から順番に処理を実行します
* 選択構造 ・・・ 何らかの条件によって分岐させいずれかの処理を実行させます
* 繰返し構造 ・・・ ある条件が満たされるまで一定の処理を繰り返します

## 7.4. 変数
**変数**はメモリの許す限りいくらでも使うことができ、変数は名前を付けて管理します。
## 7.5. アルゴリズムとフローチャート
コンピュータはプログラムに書かれた**アルゴリズム(作業手順)** にのっとり動作します。
アルゴリズムをわかりやすく記述するために用いるのが**フローチャート**である。
#### フローチャートの記号<!-- omit in toc -->
<img src="http://g-network.boo.jp/wiki/wp-content/uploads/2018/08/%E3%83%95%E3%83%AD%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%83%88-1.png" width="70%">

## 7.6. データの持ち方
### 配列<!-- omit in toc -->
メモリの連続した領域にデータを並べて管理するのが**配列**です。
配列は固定サイズでまとめて領域を確保するため、データの削除や挿入は苦手です。
### リスト<!-- omit in toc -->
データ同士を数珠つなぎにして管理するのが**リスト**です。
リストの扱うデータはポインタと呼ばれる番号がセットになっています。これはメモリ上の位置を表す番号で次のデータがメモリのどこにあるかを指し示します。
リストの特徴として、ポインタ順にデータをたどるため、配列のように添え字を使い各データに直接アクセスする使い方はできない。
#### 単方向リスト<!-- omit in toc -->
リストの一般的構造です。一方通行です。
#### 双方向リスト<!-- omit in toc -->
次のデータと前のデータのポインタを持つリストです、前後どちらにもリストをたどれます。
#### 循環リスト<!-- omit in toc -->
最後尾データは先頭データのポインタを持つリストです。
<img src="https://algo-logic.info/wp-content/uploads/2019/11/linked_lists-1-1024x742.png" width="70%">

### キュー<!-- omit in toc -->
キュー(待ち行列)は最初に格納したデータから順に処理を行うFIFO方式のデータ構造である。

### スタック<!-- omit in toc -->
スタックはキューの逆で最後に入れたデータから処理を行うLIFO方式のデータ構造である。

## 7.7. ツリー構造
### 2分木のデータ構造<!-- omit in toc -->
ツリー構造のうち節から延びる枝が2本以上のものは2分木と呼ばれます。
また2分木は左右の子にポインタを付加すると次のような配列構造になります。
<img src="http://www.kogures.com/hitoshi/webtext/hs-data-tree/tree-list.gif" width="70%">

### 完全2分木<!-- omit in toc -->
葉以外の節がすべて2つの子を持ち、根から葉までの深さが等しい2分木は**完全2分木**と呼ばれます。
### 2分探索木<!-- omit in toc -->
ツリーの左分木と右分木の関係が「左<親<右」となる2分木は**2分探索木**と呼ばれます。
このツリー構造ではデータ探索を節の中身と比較して簡単に行えます。

## 7.8. データ探索のアルゴリズム
探索のアルゴリズムには主に以下のようなものがあります。
### 線形探索法<!-- omit in toc -->
先頭から順に探索していく方法は線形探索法と呼ばれます。
線形探索法では**番兵**と呼ばれる目的のデータを配列最後尾につけることでフロー処理の簡素化を行えます。
### 2分探索法<!-- omit in toc -->
探索対象のデータ列が昇順か降順の場合、**2分探索法**を実施することで効率よくデータを求められます。
流れは次のようになります。
1. データ構造の真ん中のデータを求めているデータと比較します
2. 求めているデータに近い方の範囲(右か左)を絞り込みます
3. 絞り込んだ範囲の真ん中のデータと求めているデータを比較します
4. 1から3を繰り返すと求めたいデータが求まります。

フローチャートは以下のようになります。

<img src="https://www.fe-siken.com/kakomon/24_aki/img/06.gif" width="50%">

### ハッシュ法<!-- omit in toc -->
ハッシュ関数と呼ばれる「一定の計算式」を用いてデータの格納位置を算出する方法です。
なおデータの登録もハッシュ関数を用いて行われる必要があります。
シノニムが発生する場合オープンアドレス法やチェイン法でデータを追加します。

<img src="https://medium-company.com/wp-content/uploads/2021/09/hash1_3.png" width="50%">

### 各アルゴリズムにおける探索回数<!-- omit in toc -->
#### 線形探索法<!-- omit in toc -->
先頭にあるときと末尾にあるときの平均なので、平均探索回数は **(0+n)/2** :nはデータ範囲の最大値
#### 2分探索法<!-- omit in toc -->
半分ずつに絞り込みを行うので対数logを使うと、平均探索回数は**log2n** :nはデータ範囲の最大値
#### ハッシュ法<!-- omit in toc -->
シノニム(コリジョン)の発生確率が無視できるほど小さい場合、平均探索回数は1回

## 7.9. データを整列させるアルゴリズム
### 基本交換法(バブルソート)<!-- omit in toc -->
隣接するデータの大小を比較し、必要に応じて入れ替えることで全体を整列させるのが**バブルソート**である。
### 基本選択法(選択ソート)<!-- omit in toc -->
対象とするデータの中から最小値(or最大値)のデータを取り出し、先頭データと交換しこれを1つずつずらして繰り返すことで整列させるのが**選択ソート**である。
### 基本挿入法(挿入ソート)<!-- omit in toc -->
データ列を「整列済みのもの」と「未整列なもの」に分け、未整列の側からひとつずつ整列済みの列の適切な位置に挿入し、全体を整列させる手法が**挿入ソート**である。
### 高度な整列アルゴリズム<!-- omit in toc -->
#### シェルソート<!-- omit in toc -->
ある一定間隔沖に取り出した要素からなる部分列を整列しさらに間隔を詰めて同様の操作を行い、間隔が1になるまで繰り返して整列させる手法
#### クイックソート<!-- omit in toc -->
中間的な基準値を決めてそれよりも大きな値を集めた区分と小さな値を集めた区分に要素を振り分けてこれを繰り返すことで整列する手法
#### ヒープソート<!-- omit in toc -->
未整列データを順序木に構成し、そこから最大値(or最小値)を取り出して既整列に移す。これを繰り返して未整列部分をなくしていって整列する手法

## 7.10. オーダ記法
**オーダ記法**はアルゴリズムの計算量(実行時間)を**O(式)** の形で表すことです。
#### 各アルゴリズムのオーダ<!-- omit in toc -->
平均計算時間≒オーダ

<img src="https://avinton.com/wp-content/uploads/2020/04/sorting-algorithm-11.png" width="50%">

## 7.11. オブジェクト指向プログラミング
処理の対象を**オブジェクト**という概念でとらえ、オブジェクトの集まりとしてシステムの設計開発を行うことは**オブジェクト指向プログラミング**と呼ばれます。
詳細に説明するとオブジェクトはデータ(属性)とそれに対するメソッド(手続き)を一つにまとめた概念である。
オブジェクト指向でプログラムを設計するとモジュールの独立性が高く保守しやすいプログラムの作成が可能です。
### オブジェクト指向のカプセル化<!-- omit in toc -->
オブジェクト指向プログラミングでは**カプセル化**できることが大きな特徴です。カプセル化することでオブジェクト内部の構造は外部から知ることができなくなります。つまり、**情報隠蔽**ができることがカプセル化の利点である。
カプセル化を用いるとオブジェクトの実装方法に修正を加えてもその影響を最小限にとどめることができます。
### クラスとインスタンス<!-- omit in toc -->
オブジェクトはデータとメソッドを定義したものでした。この「オブジェクトがもつ性質」を定義したものは**クラス**と呼ばれます。
言い換えると、オブジェクトの設計図がクラスであり、データやメソッドを持っています。
この設計図に対して具体的な属性値を与えメモリ上に実体化させたものは**インスタンス**と呼ばれます。
<img src="https://medium-company.com/wp-content/uploads/2021/07/ins1.png" width="50%">

### クラスの階層構造<!-- omit in toc -->
クラスの基本的な考え方はオブジェクトを抽象化し定義することです。
クラスの階層化というのはクラスに上位、下位の階層を持たせることができるというものです。
下位クラスは上位クラスのデータやメソッドの構造を受け継ぐことができます。
上位クラスは**スーパクラス(基底クラス)** 、下位クラスは**サブクラス(派生クラス)** と呼ばれます。
サブクラスがスーパクラスの特性を引き継ぐことは**継承(インヘリタンス)** と呼ばれます。

### 汎化と特化<!-- omit in toc -->
汎化は下位クラスが持つ共通性質を抽出し上位クラスとして定義することです。
特化は抽象的な上位クラスをより具体的なクラスとして定義することです。
それぞれの関係は下記図のようになります。
<img src="https://dcross.impress.co.jp/img/dx/docs/001/711/new-business_02-03_o.jpg" width="60%">

### 集約と分解<!-- omit in toc -->
下位クラスは上位クラスの特性を分化して定義したもの。上位クラスは下位クラスを集約して定義したものという関係です。
<img src="https://www.momoyama-usagi.com/wp-content/uploads/2021/05/20200712024356.gif" width="60%">

### 多態性(ポリモーフィズム)<!-- omit in toc -->
**多態性**は同じメッセージを複数のオブジェクトに送ると、それぞれが独立した固有の処理を行うというものです。

## 7.11. UML(Unified Modeling Language)
UMLはオブジェクト指向分析・設計において用いられる統一モデリング言語である。
またこれは複数人で設計モデルを共有してコミュニケーションをとるための手段です。
UMLでは13種類の図が規定されています。これらはダイヤグラムと呼ばれます。
### UMLのダイヤグラム<!-- omit in toc -->
UMLの図は**構造図**と**振る舞い図**に分類できます。
<img src="https://livedoor.blogimg.jp/a1406yy/imgs/9/b/9b668e6f.png" width="70%">

### クラス図<!-- omit in toc -->
クラスの定義や関連付けを示す図である。
クラス内の属性と操作を記述し、クラス同士を線でつないで互いの関係を表します。

<img src="https://www.mathkuro.com/wp-content/uploads/2019/10/%E3%82%AF%E3%83%A9%E3%82%B9%E9%96%93%E3%81%AE%E9%96%A2%E4%BF%82%E3%81%BE%E3%81%A8%E3%82%81.png" width="60%">

### ユースケース図<!-- omit in toc -->
利用者視点でシステムが要求に対してどう振る舞うかを示す図である。
<img src="https://www.ogis-ri.co.jp/otc/swec/process/am-res/am/images/models/useCaseOnlineShopping.gif" width="60%">

### アクティビティ図<!-- omit in toc -->
業務や処理のフローを表す図である。

<img src="https://www.itsenka.com/images/development/uml/uml-activity20.gif" width="40%">

### シーケンス図<!-- omit in toc -->
オブジェクト間のやり取りをし系列に沿って表す図である。オブジェクト同士の相互作用を表すもので、オブジェクト下の点線で生成から消滅までを表しそこで行われるメッセージのやり取りを矢印で表します。
<img src="https://www.itsenka.com/images/development/uml/uml-sequence02.gif" width="60%">

# 8.システム構成と故障対策
## 8.1. コンピュータを動かす形態
**クライアントサーバシステム**は現在の主流の処理形態です。これは基本的には分散処理を行い、ネットワーク上の役割を2つに分け集中して管理や処理を行う部分をサーバとして残すことが特徴です。
### シンクライアントとピアツーピア<!-- omit in toc -->
#### シンクライアント<!-- omit in toc -->
シンクライアントにおけるクライアント側の端末は入力や表示部分を担当するだけで情報の処理や保管はすべてサーバに任せます。
#### ピアツーピア(P2P)<!-- omit in toc -->
ピアツーピアは完全分散処理型のシステムです。これはネットワーク上で協調動作するコンピュータ同士が対等な関係でやり取りをするものでサーバなどの一次元的に管理するものが必要としません。
### 3層クライアントサーバシステム<!-- omit in toc -->
クライアントサーバシステムの機能を**プレゼンテーション層、ファンクション層、データ層**の3つに分けて構成するシステムのことです。これに対し通常のクライアントサーバシステムのことは2層クライアントサーバシステムと呼ばれています。
#### 2階層のクライアントサーバシステムのデメリット<!-- omit in toc -->
・ビジネスロジックに変更があるとすべてのクライアントに修正が必要となる
・処理に必要なデータがネットワーク上を流れるので帯域を圧迫する
・データベースをロックする時間が長くなりがち
#### 3階層のクライアントサーバシステムのメリット<!-- omit in toc -->
・GUI操作を行うだけなのでシンクライアントが使用可能
・処理結果が返ってくるだけなのでネットワーク上を流れるデータ量の削減可能
・ビジネスロジックに変更があってもサーバ側だけ修正すればよい
・サーバ側で処理が完成する分データベースをロックする時間も短く済む
### オンライントランザクション処理とバッチ処理<!-- omit in toc -->
普段コンピュータを使って普通に行う操作を**対話型処理**と呼ばれます。
#### オンライントランザクション処理<!-- omit in toc -->
システムの稼働形態として要求に対して即座に処理行い結果が反映されるものは**オンライントランザクション処理**と呼ばれます。
#### バッチ処理<!-- omit in toc -->
リアルタイムにすぐに反映する必要のない処理の場合、一定期間ごとに処理をまとめて実行するものは**バッチ処理**と呼ばれます。

## 8.2. システムの性能指標
システムの性能を評価する指標には**スループット、レスポンスタイム、ターンアラウンドタイム**があります。
これらを評価する手法には**ベンチマークテスト**があります。これは性能測定用のソフトウェアを使って、システムの各処理性能を数値化するものです。

### スループット<!-- omit in toc -->
スループットは単位時間あたりに処理できる仕事量をあらわします。
<img src="https://i.ytimg.com/vi/qy7P2sUsOvM/maxresdefault.jpg" width="60%">

### レスポンスタイムとターンアラウンドタイム<!-- omit in toc -->
#### レスポンスタイム<!-- omit in toc -->
レスポンスタイムはコンピュータに処理を依頼し終えてから実際に何か応答が返されるまでの時間を示します。
#### ターンアラウンドタイム<!-- omit in toc -->
ターンアラウンドタイムはコンピュータに処理を依頼し始めてその応答がすべて返されるまでに時間を示します。

## 8.3. システムを止めない手法
### デュアルシステム<!-- omit in toc -->
**デュアルシステム**は2組のシステムを使って信頼性を高めるものです。このシステムでは2組のシステムが同じ処理を行いながら、処理結果を互いに突き合わせて誤動作していないかを監視します。いずれかが故障した場合に異常の発生したシステムを切り離し、残る片方だけでそのままの処理を継続します。

### デュプレックスシステム<!-- omit in toc -->
**デュプレックスシステム**は2組のシステムを用意するのはデュアルシステムと同じです。このシステムでは主系が正常に動作している間、従系ではリアルタイム性の求められないバッチ処理などの作業を担当します。また主系が故障した場合には従系が主系の処理を代替するように切り替わる。

#### ホットスタンバイ<!-- omit in toc -->
あらかじめ主系の処理を引き継ぐために必要なプログラムを起動しておくことで瞬時に切り替える待機方法である。

#### コールドスタンバイ<!-- omit in toc -->
従系は出番が来るまで別の作業をしていたり電源がOFFだったりして、切り替え時に時間がかかります。なおその分コストダウンが可能です。

## 8.4. システムの信頼性と稼働率
稼働率はトラブルに内部時に使えていた期間を割合として示すものである。この計算に用いる指標には**平均故障間隔(MTBF)** や**平均修理時間(MTTR)** などが信頼性などを表す指標として用いられます。

### RASIS<!-- omit in toc -->
RASISはシステムの信頼性を評価する概念です。

<img src="http://program.sagasite.info/wiki/index.php?plugin=attach&refer=RASIS&openfile=zu2.jpg" width="40%">

### 平均故障間隔(MTBF)と平均修理時間(MTTR)とシステム稼働率<!-- omit in toc -->
<img src="http://program.sagasite.info/wiki/index.php?plugin=attach&refer=MTBF&openfile=zu3.jpg" width="40%">

### 直列システムと並列システムの稼働率<!-- omit in toc -->
#### 直列システムの稼働率<!-- omit in toc -->
**直列システムの稼働率　= 稼働率A × 稼働率B
#### 並列システムの稼働率<!-- omit in toc -->
**並列システムの稼働率 = 1 - ((1-故障率A) × (1-故障率B))**

### 故障の耐久性<!-- omit in toc -->
**フォールトトレラント**は壊れても大丈夫なように対策を図る考え方です。
#### フェールセーフ<!-- omit in toc -->
故障が発生した際に、安全性を確保する方向で壊れるように仕向ける方法です。
故障の場合は安全性が最優先とする考え方です。
#### フェールソフト<!-- omit in toc -->
故障が発生した場合にシステム全体を停止させるのではなく機能を一部停止するなどして動作の継続を図る方法です。
故障の場合は継続性が最優先とする考え方です。
#### フールプルーフ<!-- omit in toc -->
意図しない使われ方をしても故障しないようにするという考え方です。
#### フォールトアポイダンス<!-- omit in toc -->
品質管理などを通してシステム構成要素の信頼性を高め、故障そのものの発生を防ぐ考え方です。

### バスタブ曲線<!-- omit in toc -->
故障の発生頻度と時間の関係をグラフにしたものは**バスタブ曲線**と呼ばれます。
<img src="https://persol-tech-s.co.jp/hatalabo/wp-content/uploads/2018/04/mono341_01.jpg" width="40%">

### システムに必要な経費<!-- omit in toc -->
システムに必要となるすべてのコストは**TCO(Total Cost of Ownership)** と呼ばれます。
TCO=初期コスト+運用コスト

## 8.5. バックアップ
バックアップを行う際には以下のような点に注意します。
1. 定期的にバックアップを行う
2. バックアップを行う媒体を分ける
3. 業務作業中にバックアップをしない

### バックアップの方法<!-- omit in toc -->
バックアップには3種類の方法があり、これらを組み合わせることで効率よくバックアップを行うことができます。
#### フルバックアップ<!-- omit in toc -->
保存されているすべてのデータをバックアップするのがフルバックアップである。障害発生時に直前のバックアップだけで元の状態に戻せます。
#### 差分バックアップ<!-- omit in toc -->
前回のフルバックアップ以降に作成変更されたファイルだけをバックアップするのが差分バックアップである。障害発生時に直近のフルバックアップと差分バックアップを使い元の状態に戻します。
#### 増分バックアップ<!-- omit in toc -->
バックアップの種類の関係なく、前回のフルバックアップ以降に作成変更されたファイルだけをバックアップするのが増分バックアップである。障害発生時は元の状態に復元するために直近となるフルバックアップ以降のバックアップ全てが必要となる。